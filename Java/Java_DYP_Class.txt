
---------------- Java Programming -----------------------

	Computer ---> 
	Language --->
	Programming Languages --> 



		     SIMULA
		     COBOL								   |-- Sun Microsystem --> Java
	Assembly --> Fortran ----> ALGOL60 --> CPL --> BCPL-----> B -----> C ----> C++ ====|-- Microsoft corpo.--> .Net
		     RPG	    (1960)   (1963)    (1967)    (1970)   (1972) (1983-84) |-- CWI -------------> Python
		     BASIC								   |
		     Pascal
		     ....


	// History of Java: 


		- JAMES GOSLING Introduced the Java Programming language.

		- Initially he started with the platform independancy, and developed GreenTalk with ext. (*.gt)

		- After some days he joined the Sun Microsystem, as head of green project team, formed to develop

		- The platform independent language as a internal tools of the company to develop application
		  for different consumer electronic product.

		 - 1990 --> Touch sencetive application

		 - 1991 -> language named Oak is introduced.

		 - 1995 --> OAK renamed as Java

// Different versions of Java: 

		1995 - jdk alpha and beta
		1996 - jdk 1.0
		1997 - jdk 1.1

		1998 - J2SE 1.2
		2000 - J2SE 1.3 
		2002 - J2SE 1.4 
		
		2004 - J2SE 5.0 

		2006 - Java SE 6
		2011 - Java SE 7 
		2014 - Java SE 8 
		
		2017 - Java SE 9                   Onwards ---> JSE 9 ...
		2018 - Java SE 10 (March)
		     - Java SE 11 (September)

		2019 - Java SE 12 (March)
		     - Java SE 13 (September)

		2020 - Java SE 14 (March)
		     - Java SE 15 (September)

		2021 - Java SE 16 (March)
		     - Java SE 17 (September)

		Java SE 18 (to be released by March 2022)



// ---------------------------------------------------------------------------------------------

	Different Java Editions:


			     |-> J2SE(Standard Edition)
			     |
 		Java --------|-> J2EE(Enterprise Edition)
			     |
			     |-> J2ME( Micro Edition)


// ----------------------------------------------------------------------------------------------

	// Java Environment: 

	Platform = OS + Processor Arct.

	It is basically divided into 2 parts

		jre --> java runtime environment: Needed to run the java program
		jdk ---> java developement Needed to develop and run the java program

//----------------------------------------------------------------------------------------------------------


	// Java Buzzwords (Features of Java)	

		-  Simple 
		-  Object Oriented
		-  Portable
		-  Platform Independent
		-  secure
		-  Robust
		-  Architecture neutral
		-  half compiled and half Interpreted
		-  Multithreaded
		-  Distributed
		-  Dynamic
		-  High Performance
//------------------------------------------------------------------------------------------------------------

	// Differences Between C and Java

		https://www.interviewbit.com/blog/difference-between-c-and-java/


	// Differences Between C++ and Java

		https://www.interviewbit.com/blog/difference-between-cpp-and-java/



//----------------------------------------------------------------------------------------------------------

// Execution flow of C/C++ and Java	


		C/C++									Java

	Instructions		Progr_nm					     *.java
		|_________________|							|
			 |								|	
			 |         Debug					     Compile(javac)	
	source code	*.c/*.cpp <---|							|
			 |            |							|
			 |            |						    *.class
		      Compile ------->| Compile-time 				    (byte code)	              		 ^
			 |            | error						|                	 Compile |
			 |            |							|			===================
	backup file    *.bak          |					-------------------------------------   Interpreter |
			 |            |					|		|		| ..                V
			 |            |				       JVM             JVM             JVM --> (Platform dependent JVM)	
	 Linker -------->| ---------> |  Linker error			|		|		|
			 |            |                               Windows         Linux            MAC  
			 |            |                                 | 		|		|                          
	object code    *.obj	      |				     Native code    Native code     Native code	
			 |            |					|		|		|
			 |	      ^				      Run              RUN             Run	
     Executable file   *.exe	      |                                 |               |               |
			 |	      |	                             Output           Output          Output  
		   	Run --------->| Runtime Error
			 |
		       Output							WRITE ONCE RUN EVERYWHERE	



//---------------------------------------------------------------------------------------------------------


	Java Editors and IDE's
	======================

		Editor: Notepad, Editplus, Notepad++ ...
		
		IDE: Best Java IDEs
			Eclipse. Platform – Linux/macOS/Solaris/Windows. ...
			NetBeans. Platform – Linux/macOS/Solaris/Windows. ...
			IntelliJ IDEA. Platform – Linux/macOS/Windows. ...
			BlueJ. Platform – Linux/macOS/Windows. ...
			(Oracle) JDeveloper. Platform – Linux/macOS/Windows. 


	Now we have see, how to write a code where:

		1. Use any editor/ide

		2. Install jdk/jre (https://www.oracle.com/in/java/technologies/javase/javase8-archive-downloads.html)

		3. Use notepad as a editor and write a code as

			class <cls_nm>
			{
				public static void main(String []args)
				{
					------------------;
					------------------;
					program_body ;
					------------------;
					------------------;
				}
			}

			class Demo
			{
				public static void main(String []args)
				{
					System.out.print("Welcome to Java Programming");
				}
			}

		4. Save the code in C:\Program Files\Java\jdk-17.0.1\bin As <class_nm>.java

		5. win+r --> cmd --> enter (attend the folder where the source file, compiler and interpreter is present) as

			C:\Users\hp>cd\
			C:\>cd "Program Files\Java\jdk-17.0.1\bin"
			C:\Program Files\Java\jdk-17.0.1\bin>javac Demo.java     (compilation where you get the bytecode (*.class) )
			C:\Program Files\Java\jdk-17.0.1\bin>java Demo  	 (Byte code interpretation)
				Welcome to Java Programming
			C:\Program Files\Java\jdk-17.0.1\bin>

	//------------------------------------------------------------------------------------------------------------------

	How to run, same code when source file (*.java) is in different folder
				
			C:\Users\hp>e:
			E:\>cd myjavafiles
			E:\myjavafiles>javac First.java

				'javac' is not recognized as an internal or external command,
				operable program or batch file.

			E:\myjavafiles>set path=C:\Program Files\Java\jdk-17.0.1\bin
			E:\myjavafiles>javac First.java
			E:\myjavafiles>java First
				Welcome to Java Programming-First
			E:\myjavafiles>

		Note that the path is applicable till the current session of the command prompt.
		to set the path in the permanent manner set the path in Environmeent variable


		Setting the environment variable: this pc --> rh+ click ---> properties --> adv. system settings
						--> Advanced tab --> environment variable --> user variable path


				-if already path is there -> edit --> new-> paste path (C:\Program Files\Java\jdk-17.0.1\bin)

				otherwise  user variable path--> new and write

				variable name --> path
				variable value --> C:\Program Files\Java\jdk-17.0.1\bin) --> ok....

//-------------------------------------------------------------------------------------------------------------
	Youtube Link: https://youtu.be/RBxum7M3B94?si=jepmNZAtetZfJKFp
//-------------------------------------------------------------------------------------------------------------


	Details of welcome program:
	============================

	class WelcomeProg
	{
		public static void main(String []args)
		{
			System.out.print("Welcome to Java by Archer InfoTech");
		}
	}
	
	Line 1: class WelcomeProg:

			class: It is keyword which allows you to create your own type.
			WelcomeProg: this is name of UDT, it must be valide identifier. Internally in java lib, the have
					  choosen, First letter of class name in uppercase and all other in lowercase if it is
					  made from from one word, if multiple words then first character of each word in ucase
					  and all other in lcase.

						e.g.	First, Demo, FirstProgram, ExampleDemoWelcome
					It is recommended, not compalsory

	Line 3: public static void main(String []args) 

			public: it is used to define the visiblity of method main(), coz the javac and java are not members of class
				as a outsiders they must have access to class members therefore visibility is public.

			static: The static members gains the memory space when class is loaded into memory, no need of object
				creation. therefore the method main() decl. as static

			void: It is returning type of method main(), it is void coz java program does not return any value to OS

			main(): It is method name, and as it is main(), it is considered as a starting point of of your program

			String []args: String is Built-in class from java.lang package, it is language support package, which is 
					imported bydefault. []args it is array of arguments, which is passed automatically at the
					time of execution from commandline, in absence null is collected.
					simply it is array of objects.

	Line 5:  System.out.print("Welcome to Java");

			"Welcome to Java" : It is data, to be displayed
			print() is a method from PrintStream class used to display the data on screen.
			out is predefined object of PrintStream class, declare ed as a static in System class
			System is a class from java.lang package.


	>>javac WelcomeProg.java (WelcomeProg - is a file name)
	>>java WelcomeProg (WelcomeProg - class name containing main() method)

 //-----------------------------------------------------------------------------------------------------------------------

	// When we write a file generaly we keep file name and main class name same, but it may be different
	   In such case, compile using file name and run using main class name.
	
	   if a java file having two or more class defined within it, then there are those number of class
	   files, from which we have to use class name containing main() to run the program.

	lets see ...

class Sample
{
}
class Test
{
}
class WelcomeProgram
{
	public static void main(String []args)
	{
		System.out.print("Welcome to Java by Archer InfoTech");
	}
}

 --------- output ----------

C:\Users\archerinfotech>d:

D:\>cd jdyp

D:\jdyp>javac Welcome.java

D:\jdyp>java WelcomeProgram
Welcome to Java by Archer InfoTech
D:\jdyp>

//------------------------------------------------------------------------------------------

	// Knowing the String []args

	 - args : It refers to arguments, you can choose any name for it rather than args
	 - [] args: It represents array name
	 - String []args: Array of String objects, where String is class from java.lang package,
			  which is imported bydefault  

class MainArgu
{
	public static void main(String []args)
	{
		System.out.println(args);
		System.out.println("0 - "+args[0]);
		System.out.println("1 - "+args[1]);
		System.out.println("2 - "+args[2]);
	}
}

/*
  ------- How to run --------

	case 1:
		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu
		[Ljava.lang.String;@4517d9a3
		Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
       		 at MainArgu.main(MainArgu.java:6)

	case 2:

		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu hello all
		[Ljava.lang.String;@4517d9a3
		0 - hello
		1 - all
		Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 2 out of bounds for length 2
        		at MainArgu.main(MainArgu.java:8)

	case 3:
		D:\jdyp>javac MainArgu.java

		D:\jdyp>java MainArgu good morning all
		[Ljava.lang.String;@4517d9a3
		0 - good
		1 - morning
		2 - all

		D:\jdyp>java MainArgu good morning all of you
		[Ljava.lang.String;@4517d9a3
		0 - good
		1 - morning
		2 - all

		D:\jdyp>java MainArgu try 123 or 456
		[Ljava.lang.String;@4517d9a3
		0 - try
		1 - 123
		2 - or

 * Note that when there is no any argument at location, the interpreter will generate an error message at
   runtime class Exception which will terminate the program.

*/

//----------------------------------------------------------------------------------------------------

	Now we need to proceed using the path fillowed in the C and C++

	i.e.
				constant
	charcter set -----> 	keyword ------> Instructions ----> program ----> module ---> software
				variable


	Java Character set:

		- ASCII(American Standard Code for Information Interchange):  Provides the binary string to all symbols present
		  in the US English, which are used in different electronic devices.

		- ASCII used to code in english, but java supports different human understable languages for coding. means java
		  having rich character set as cmp to c/c++. The Standard Code system names unicode system used in the 
		  java which provides the 16 bit binary string to each symbol for different languages.     

		What is difference between ASCII and UNICODE.
		 - ASCII is suitable for basic, English-only text.
		 - Unicode is a comprehensive encoding system that supports global languages and symbols, making it the standard 
		   for modern computing.



	// Constants: These are the elements in the program having fix value.

							      Java Constants
								    |
							---------------------------
							|			  |
						    Numeric 		     Non-Numeric
							|			  |
						-----------------	-----------------
						|		|	|		|	
					   Integer     floating-point  character     String
					-6,4,56    -5.3,7.0,78.6755    'a', '$'     "A", "Hello"		
									'H' '4'	     "a123"

	// Keyword: These are reserved words, whose meaning is already known to compiler. 


		abstract	continue	for		new		switch

		assert***	default		goto*		package		synchronized
	
		boolean		do		if		private		this

		break		double		implements	protected	throw

		byte		else		import		public		throws

		case		enum****	instanceof	return		transient

		catch		extends		int		short		try

		char		final		interface	static		void

		class		finally		long		strictfp**	volatile

		const*		float		native		super		while 

		*	 	not used
		**	 	added in 1.2
		***	 	added in 1.4
		****	 	added in 5.0

	(https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)


 	Java Data Types: Tool used for the memory allocation.

		- Primitive data types: These are provided by the language itself. e.g. int, char, byte..
		- Non-Primitive data types: The are defined by the programmers according to the need. e.g. class, interface


						Java Data Types
							|
					---------------------------------
					|				|
				Primitive Data Types		Non-Primitive Data Types
					|				|
			   --------------------------              - String
			   |			    |   	   - Array
		      Numeric		 	boolean	   	   - Vector
			  |	                (1 bit)
			------------------
			|		 |
		   Integrals	      character	
			|                |
	-------------------------      char(2)		
	|			|				
      integer		     floating point    		
      |				|					 
      |- byte (1)		|- float(4)    
      |- short (2)		|- double(8)
      |- int(4)
      |- long(8)


	- The defalt integer value is considered as a int and default fractional value considered as double.
	- When you decl the variable, java demands for the init. of variables, otherwise it will generate the
	  error message, 
				"variable xxx might not have been initialized"

	- When the value of variable having higher type is assigned to variable of lower type, then it will
	  generate the error message

		e.g.
			a=c;	gives the following error, when a is byte variable and c is int variable

			"possible lossy conversion from int to byte" 
		 
		In such case, where you want to convert the value from higther type to lower type, go for
		the type casting;

			i.e.	a=(byte)c;

		Note carefully that, lower type to higher type promoted automatically.

	- The long costant is represented using 'l' or 'L' as a prefix and for the float 'f' or 'F' is used.

	- Java allows you to decl. the variables anywhere in the program, just decl before using it.


	* What is difference between C,C++ data types and java data types?
	* Why java character needs 2 bytes?
	* Which are different higher level anguages used to code in java.

class Values
{
	public static void main(String []args)
	{
		int x=10;
		byte b=(byte)x;
		short s=(short)x;
		long l=25;
		System.out.println("\n x="+x+"\t b="+b+"\t s="+s+"\t l="+l);

		float f1=45.23F;
		double d1=f1;
		System.out.println("\n f1="+f1+"\t d1="+d1);

		float f2=(float)d1;
		System.out.println("\n f2="+f2);
	}

}

	----------- Execution Attempts ----------

D:\jdyp>javac Values.java
Values.java:6: error: incompatible types: possible lossy conversion from int to byte
                byte b=x;
                       ^
Values.java:7: error: incompatible types: possible lossy conversion from int to short
                short s=x;
                        ^
Values.java:11: error: incompatible types: possible lossy conversion from double to float
                float f1=45.23;
                         ^
Values.java:15: error: incompatible types: possible lossy conversion from double to float
                float f2=d1;
                         ^
4 errors

// after changing 

D:\jdyp>javac Values.java

D:\jdyp>java Values

 x=10    b=10    s=10    l=25

 f1=45.23        d1=45.22999954223633

 f2=45.23


	* What is widening conversion and narrowing conversion?

	In Java, widening conversion and narrowing conversion are two types of type conversions that occur when a value of one 
	data type is converted to another. These conversions happen in the context of primitive data types and determine whether 
	data is safely transformed or if precision might be lost.

	- Widening Conversion (Implicit Conversion): Converting a smaller (or less precise) data type to a larger (or more precise) 
	  data type. This is done automatically by the Java compiler because there’s no risk of data loss.

	- Narrowing Conversion (Explicit Conversion): Converting a larger (or more precise) data type to a smaller (or less precise) 
	  data type. This is not done automatically because there’s a risk of data loss or truncation.


//----------------------------------------------------------------------------------------------------------------------

	// Different ways of Data Input in Java

 1. Data Input by direct init

class InputUsinginit
{
	public static void main(String []args)
	{
		int x=134;	
		byte b=10;	
		char ch='$';	
		double db=56.2323;
		float ft=3.4F;
		boolean b=true;

		System.out.println("x="+x);		
		System.out.println("b="+b);
		System.out.println("value of ch is "+ch);
		System.out.println("db is"+db);
		System.out.println("float value "+ft);
		System.out.println("boolean value "+b);
	}
}

//----------------------------------------------------------------------------------------

 2. Data Input as a commandline argument

class DataInputCmdln
{
	public static void main(String []args)
	{
		String s1="-",s2="-";

		s1=args[0];
		s2=args[1];

		System.out.printn("String s1 is: "+s1);
		System.out.printn("String s2 is: "+s2);
	}
}
output:

E:\javapfsdn23>javac DataInputCmdln.java

E:\javapfsdn23>java DataInputCmdln hello all
String s1 is: hello
String s2 is: all

E:\javapfsdn23>java DataInputCmdln hello
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1
        at DataInputCmdln.main(DataInputCmdln.java:8)

E:\javapfsdn23>java DataInputCmdln
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
        at DataInputCmdln.main(DataInputCmdln.java:7)


How to deal with such runtime errors called exception, which are generated when we will try to 
access the location which is not present.


class DataInputCmdln
{
	public static void main(String []args)
	{
		String s1="-",s2="-";

		try
		{
			s1=args[0];
			s2=args[1];
		}
		catch(Exception e){}

		System.out.println("String s1 is: "+s1);
		System.out.println("String s2 is: "+s2);
	}
}

output:

E:\javapfsdn23>javac DataInputCmdln.java

E:\javapfsdn23>java DataInputCmdln hello all
String s1 is: hello
String s2 is: all

E:\javapfsdn23>java DataInputCmdln hello
String s1 is: hello
String s2 is: -

E:\javapfsdn23>java DataInputCmdln
String s1 is: -
String s2 is: -


//----------------------------------------------------------------------------------------------------

We know the input is in form of strings and is is true even when we try to pass numeric 
values coz they are automatically converted into strings, then how to input the numeric values

class DataInputCmdln
{
	public static void main(String []args)
	{
		int x=args[0];
		double y=args[1];

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
	}
}

on compile 


E:\javapfsdn23>javac DataInputCmdlnNumeric.java
DataInputCmdlnNumeric.java:6: error: incompatible types: String cannot be converted to int
                int x=args[0];
                          ^
DataInputCmdlnNumeric.java:7: error: incompatible types: String cannot be converted to double
                double y=args[1];
                             ^
2 errors

can be eliminated using ...
class DataInputCmdlnNumeric
{
	public static void main(String []args)
	{
		String x=args[0]; // "12"--> 12
		String y=args[1];

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
		System.out.println("Sum is: "+(x+y));
	}
}

will gives....!! 
D:\jdyp>javac DataInputCmdlnNumeric.java

D:\jdyp>java DataInputCmdlnNumeric 12 34
x is: 12
y is: 34
Sum is: 1234

To get correct output...
we have to convert the arguments in args(which are always Strings). into the required primitive
data type. And for that we have use pre-defined functionality,

 i.e. there are group of classes defined to represent the primitive type into equivalent 
 object type, known as "Wrapper Classes". All such class having method

	static <return_type> parse<xxxx>(String arg);

 which will convert the string into curresponding primitive numeric value.	

	byte --> Byte
	short --> Short
	int --> Integer
	long --> Long
	float --> Float
	double --> Double


class DataInputCmdlnNumeric
{
	public static void main(String []args)
	{
		int x=Integer.parseInt(args[0]); // "12"--> 12
		double y=Double.parseDouble(args[1]);

		System.out.println("x is: "+x);
		System.out.println("y is: "+y);
		System.out.println("Sum is: "+(x+y));
	}
}
E:\javapfsdn23>javac DataInputCmdlnNumeric.java

E:\javapfsdn23>java DataInputCmdlnNumeric
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
        at DataInputCmdlnNumeric.main(DataInputCmdlnNumeric.java:6)

E:\javapfsdn23>java DataInputCmdlnNumeric 12 67.45
x is: 12
y is: 67.45
Sum is: 79.45

//-------------------------------------------------------------------------------------------

	// 3. Input using java.io.InputStreamReader and java.io.BufferedReader

	In this communication InputStreamReader and BufferedReader are predefined classes from java.io Package.
	from which InputStreamReader communicates with default sterams System.in and provides the data to 
	BufferedReader and then after processing that data converted into string by the BufferedReader using
	methods like readLine().

	* How may default stream are present in java.
	- In Java, three default streams are provided for handling input and output. These streams are part of 
	  the java.lang.System class and are available by default for every Java application

		- System.in:  Used to read input from the standard input stream, typically the keyboard.
		- System.out: Used to write output to the standard output stream, typically the console.
		- System.err: Used to write output to the standard error stream, typically for logging 
			      or error messages.

 // Input different values from keyboard and just display them.

import java.io.BufferedReader;
import java.io.InputStreamReader;
class IOUsingBI
{
	public static void main(String []args)
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);

		System.out.println("\n Enter the string: ");
		String str = br.readLine();
		
		System.out.println("\n Enter the int value: ");
		int x=Integer.parseInt(br.readLine());
		
		System.out.println("\n Enter the fractional value: ");
		double y=Double.parseDouble(br.readLine());

		System.out.println("\n Enter the short value: ");
		Short z=Short.parseShort(br.readLine());

		System.out.printn("\n str: "+str+"\n x="+x+"\n y="+y+"\n z="+z);
	}
}

D:\jdyp>javac IOUsingBI.java
IOUsingBI.java:12: error: unreported exception IOException; must be caught or declared to be thrown
                String str = br.readLine();
                                        ^
IOUsingBI.java:15: error: unreported exception IOException; must be caught or declared to be thrown
                int x=Integer.parseInt(br.readLine());
                                                  ^
IOUsingBI.java:18: error: unreported exception IOException; must be caught or declared to be thrown
                double y=Double.parseDouble(br.readLine());
                                                       ^
IOUsingBI.java:21: error: unreported exception IOException; must be caught or declared to be thrown
                Short z=Short.parseShort(br.readLine());
                                                    ^
4 errors

	// Now we have two options to solve the problem.
		
	- Use try-catch block
	- use throws clause


 - using try-catch

import java.io.BufferedReader;
import java.io.InputStreamReader;
class IOUsingBI
{
	public static void main(String []args)
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);

		try
		{
			System.out.println("\n Enter the string: ");
			String str = br.readLine();
		
			System.out.println("\n Enter the int value: ");
			int x=Integer.parseInt(br.readLine());
		
			System.out.println("\n Enter the fractional value: ");
			double y=Double.parseDouble(br.readLine());

			System.out.println("\n Enter the short value: ");
			Short z=Short.parseShort(br.readLine());

			System.out.println("\n str: "+str+"\n x="+x+"\n y="+y+"\n z="+z);
		}
		catch(Exception e){ }
	}
}

 ------ Output -----------------

D:\jdyp>javac IOUsingBI.java

D:\jdyp>java IOUsingBI

 Enter the string:
hello

 Enter the int value:
12

 Enter the fractional value:
6.7

 Enter the short value:
34

 str: hello
 x=12
 y=6.7
 z=34

	// Character input using java.io.InputStreamReader and java.io.BufferedReader
	
- use throws clause

import java.io.BufferedReader;
import java.io.InputStreamReader;
class CharIOUsingBI
{
	public static void main(String []args) throws Exception
	{
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);
		char ch=' ';
		
		System.out.println("\n Enter the character: ");
		ch = br.readLine().charAt(0);
		
		System.out.println("\n character is="+ch);
	}
}


//-------------------------------------------------------------------------------------------

	4. Using java.util.Scanner to take the input from keyboard

import java.util.Scanner;
class InputUsingScannerObject
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		String str="";
		int x=0;
		double db=0.0;
		char ch='$';

		System.out.println("Enter any String: ");
		str=sc.nextLine();

		System.out.println("Enter any int value: ");
		x=sc.nextInt();

		System.out.println("Enter any double value: ");
		db=sc.nextDouble();

		System.out.println("Enter any character: ");
		ch=sc.next().charAt(0);

		System.out.println("String str: "+str);
		System.out.println("int value: "+x);
		System.out.println("double value: "+db);
		System.out.println("char value: "+ch);		
	}
}

output:

E:\javapfsdn23>javac InputUsingScannerObject.java

E:\javapfsdn23>java InputUsingScannerObject
Enter any String:
aaaa
Enter any int value:
12
Enter any double value:
3.3
Enter any character:
r
String str: aaaa
int value: 12
double value: 3.3
char value: r

 //-------------------------------------------------------------------------------------------------------

	5. Using javax.swing.JOptionPane.showInputDialog()

import javax.swing.JOptionPane;
class InputUsingShowIpDialog
{
	public static void main(String []args)
	{
		int x=0;
		double y=0.0;

		x=Integer.parseInt(JOptionPane.showInputDialog("Enter any int value: "));	
		y=Double.parseDouble(JOptionPane.showInputDialog("Enter any double value: "));	

		System.out.println("int value: "+x);
		System.out.println("double value: "+y);		
	}
}	

///=========================================================================================================================

// Operators in Java: Operators are used to process the data. There are following operators
			      present in the java.

			- Assignment Operators (= and short-hand operators)
			- Unary Operators ( - ++ -- (type) )
			- Arithmetic Operators ( + - * / % )
			- Relational Operators ( < <= > >= == != )
			- Logical Operators (&& || !)
			- conditional Operator ( ? : )
			- Bitwise Operators (& | ^ >> << >>>)
			- special Operators (. and instanceof )




- Assignment Operators (= and short-hand operators): will assigns constant value at its rh+, value of variable at its rh+ or
			answer of exper at its rh+ to variable at left.

		e.g.
			int x=10;	int y=x;	int z=x+y;

			shorthand expr: 	suppose,	x=x+10	can be written as x+=10;
								x=x/10  --> x/=10
								....

class DemoAssignment
{
	public static void main(String []args)
	{
		int x=10;
		int y=x;
		int z=x+y;
	
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		x+=100;
		y*=2;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

	}
}

//-------------------------------------------------------------------------------------------------------------------

- Unary Operators ( - ++ -- (type) )

	- will gives oppisite value
	++ incr by 1
	-- decr by 1

		inc/dec
		  |
	--------------------------
	|			|
     pre 		      post
  (++x, --x)		  (x++, x--)		


	++x  <-----> x=x+1	<------> x++
	--x  <-----> x=x-1      <------> x--

	when these operators are used in the expression, 

		pre --> expr --> post

	suppose x=5, and y=9

		z = ++x + y-- ;

	- find the basic expr
	- operate all pre operators
	- calc. the basic expr. with current values
	- operator all post operators

	- x becomes 6
	- assigned 15 to z
	-y becomes 8

import java.util.Scanner;
class DemoUnary
{
	public static void main(String []args)
	{
		int x=0;
		int y=0;
		int z=0;
	
		Scanner sc= new Scanner(System.in);
		System.out.println("\n Enter the values of x and y: ");
		x=sc.nextInt();
		y=sc.nextInt();

		z=-x;
		x++;
		--y;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=++x+y--;
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);
	}
}

//------------------------------------------------------------------------


	(type): It refers to type casting, means changing the data type of variable obly at the of calc.


import java.util.Scanner;
class DemoCasting
{
	public static void main(String []args)
	{
		int x=0,y=0;
		double z=0;
	
		Scanner sc= new Scanner(System.in);
		System.out.println("\n Enter the values of x and y: ");
		x=sc.nextInt();
		y=sc.nextInt();  // 13, 5

		z=x/y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=(double)x/y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=x/(double)y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

		z=(double)x/(double)y;		
		System.out.println("\n x="+x+"\t y="+y+"\t z="+z);

	}
}

output: 
E:\jprodyp>javac DemoCasting.java

E:\jprodyp>java DemoCasting

 Enter the values of x and y:
13
5

 x=13    y=5     z=2.0

 x=13    y=5     z=2.6

 x=13    y=5     z=2.6

 x=13    y=5     z=2.6

//----------------------------------------------------------------------------------------
- Arithmetic Operators ( + - * / % )

	// program to calc the simple interst.

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoArith
{
	public static void main(String []args) throws Exception
	{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int p=0,n=0;
		double r=0.0,si=0.0;

		System.out.println("Enter the value of p: ");
		p=Integer.parseInt(br.readLine());

		System.out.println("Enter the value of r: ");
		r=Double.parseDouble(br.readLine());

		System.out.println("Enter the value of n: ");
		n=Integer.parseInt(br.readLine());
	
		si=(p*r*n)/100;

		System.out.println("Simple Interst is: "+si);
	}
}


	Using % and / operator

	lets see simple example, we have to calculate 13/5

		   2 <------------- (13/5)
		________
	      5 )  13
		 - 10
		---------
		    3 <----------- (13%5)

 lets see some examples, ovserve the result and write the conclusion

	13/5=2		13%5=3
	27/7=3		27%7=6
	67/9=7		67%9=4
	123/10=12	123%10=3
	459/10=45	459%10=9
	3857/10=385	3857%10=7
	7/10=0		7%10=7

	- Div by 10 eliminates the last digit from number.
	  and mod by 10 gives the last digit.
	- In N/D, when N<D then div is 0 and rem is N

   // Enter any 3 digit number from keyboard and find addition of its all digits.
  // no=285 then ans = 5+8+2 => 15

import java.util.Scanner;
class DemoDivMod
{
	public static void main(String []args)
	{
		int no=0,rem=0,tot=0;
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter any 3 digit number: ");
		no=sc.nextInt(); //285
	
		rem=no%10; //5
		tot=tot+rem; // 0+5=5
		no=no/10; //28
	
		rem=no%10; //8
		tot=tot+rem; // 5+8=13
		no=no/10; //2	

		rem=no%10; //2
		tot=tot+rem; // 13+2=15
		no=no/10; //0

		System.out.println("\n Total is "+tot);
	}		
} 

Unlike C/C++, Here in java you can operate the % operator on fractional and -ve values,
when you operate the % operator on -ve values the sign of ans is taken as the sign of N form N/D.
class DemoMod
{
	public static void main(String []args)
	{
		int x=-13, y=5, z=-2;

		System.out.println("-%+: "+(x%y));
		System.out.println("-%-: "+(x%z));
		System.out.println("+%-: "+(21%z));
		System.out.println("+%+: "+(33%4));

		System.out.println("+%+: "+(33.5%4));
		System.out.println("+%+: "+(36.5%2.3));
	}
}

//-----------------------------------------------------------------------------------------

	// Relational Operators: (<, <=, >, >= ==, !=): These operators are used to find the
		relation between two operands. It will forms the condition which is useful in the
		conditional conditional control statements.

		thw ans of condition is boolean value true when it is true and false when false.


	suppose x=23	y=5;

		x>y	----> true 	means if we write z=x>y then true assigned to z.

		x!=y	----> true 
		
		y<1	----> false
		
		x%10==0 ----> false 

		100%y==0 ---> true 

class DemoRel
{
	public static void main(String []args)
	{
		int x=23,y=5;
		boolean b;
		System.out.println("\n x is: "+x+"\t y is: "+y);

		b=x>y;
		System.out.println("\n (x>y) is: "+b);

		b=x!=y;
		System.out.println("\n (x!=y) is: "+b);

		b=y<1;
		System.out.println("\n (y<1) is: "+b);

		b=x%10==0;
		System.out.println("\n (x%10==0) is: "+b);

		b=100%y==0;
		System.out.println("\n (100%y==0) is: "+b);
		
	}
}
output

E:\jprodyp>javac DemoRel.java

E:\jprodyp>java DemoRel

 x is: 23 y is: 5

 (x>y) is: true

 (x!=y) is: true

 (y<1) is: false

 (x%10==0) is: false

 (100%y==0) is: true

//-----------------------------------------------------------------------------------------------

	/// Logical Operator ( && || !): These operators are used to join two or more conditions

		when the conditions are joind by

		- && --> gives true only when both true otherwise false
		- || --> gives false only when both false otherwise true
		- !  --> gives
				!(true) ---> false
				!(false) ---> true
				

	suppose x=23	y=5;

		(x>y)&&(y<100)	----> true 
		(x>y)&&(y>100)	----> false

		(x>y)||(y>100)	----> true 
		(x<y)||(y>100)	----> false
	
		!(x!=y)	----> false 	
		!(y<1)	----> true


class DemoLogical
{
	public static void main(String []args)
	{
		int x=23,y=5;
		boolean b;
		System.out.println("\n x is: "+x+"\t y is: "+y);

		b=(x>y)&&(y<100);
		System.out.println("\n ((x>y)&&(y<100)) is: "+b);

		b=(x>y)&&(y>100);
		System.out.println("\n ((x>y)&&(y>100)) is: "+b);

		b=(x>y)||(y>100);
		System.out.println("\n ((x>y)||(y>100)) is: "+b);

		b=(x<y)||(y>100);
		System.out.println("\n ((x<y)||(y>100)) is: "+b);

		b=!(x!=y);
		System.out.println("\n (!(x!=y)) is: "+b);

		b=!(y<1);
		System.out.println("\n (!(y<1)) is: "+b);
		
	}
}

output: 
E:\jprodyp>javac DemoLogical.java

E:\jprodyp>java DemoLogical

 x is: 23        y is: 5

 ((x>y)&&(y<100)) is: true

 ((x>y)&&(y>100)) is: false

 ((x>y)||(y>100)) is: true

 ((x<y)||(y>100)) is: false

 (!(x!=y)) is: false

 (!(y<1)) is: true

///--------------------------------------------------------------------------------------
// Conditional operator or ternary operator or if-then-else operator(?:):

		This is the only operator which has decision abiity.
	
		syntax:

			<condition> ? <options>;

			<condition> ? <true_part> : <false_part> ;

	// WAP to find the max from 2 nos

import java.util.Scanner;
class DemoConditionalOperator
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int x=0,y=0;

		System.out.println("\n Enter any two nos: ");
		x=sc.nextInt();
		y=sc.nextInt();

		int z = (x>y) ? x : y ;
		System.out.println("\n Max no: "+z);
	}
}

output:
E:\jprodyp>javac DemoConditionalOperator.java

E:\jprodyp>java DemoConditionalOperator

 Enter any two nos:
45
78

 Max no: 78

E:\jprodyp>java DemoConditionalOperator

 Enter any two nos:
90
23

 Max no: 90

///------- Nesting of conditional operators


	// WAP to find the max from 3 nos

import java.util.Scanner;
class DemoConditionalOperator1
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int x=0,y=0,z=0;

		System.out.println("\n Enter any three nos: ");
		x=sc.nextInt();
		y=sc.nextInt();
		z=sc.nextInt();

		int max = (x>y) ? (x>z?x:z) : (y>z?y:z) ;
		System.out.println("\n Max no: "+max);
	}
}

output:
E:\jprodyp>javac DemoConditionalOperator1.java

E:\jprodyp>java DemoConditionalOperator1

 Enter any three  nos:
11
22
33

 Max no: 33

E:\jprodyp>java DemoConditionalOperator1

 Enter any three nos:
111
22
33

 Max no: 111

E:\jprodyp>java DemoConditionalOperator1

 Enter any three nos:
11
222
33

 Max no: 222

//-----------------------------------------------------------------------------------------------------------


//-----------------------------------------------------------------------------------------------------------------------

   	/// Bitwise Operator: [ & | ^ >> << >>> ]
 
    These operators are used in the bit level operations.

        & ==> 1 & 1 -> 1 otherwise 0
        | ==> 0 | 0 -> 0 otherwise 1

              0^0
        ^ -->     ==> 0 otherwise 1
              1^1

    suppose x=10       y=12

        (0000 1010)     (0000 1100)

    (x&y)       (x|y)       (x^y)

    1010        1010        1010
   &1100       |1100       ^1100
  ========    ========     =======
    1000        1110        0110
    (8)          (14)        (6)


    x=10 (0000 1010)     y=12  (0000 1100)

     z=x<<2              z=y>>2
       (0010 1000)       (0000 0011)
       ==>40            ==> 3


class DemoBitwise
{
	public static void main(String []args)
	{
		int x=10,y=12;
		System.out.println("\n (x&y) is"+ (x&y) );

		System.out.println("\n (x|y) is"+ (x|y) );

		System.out.println("\n (x^y) is"+ (x^y) );

		System.out.println("\n (x<<2) is"+ (x<<2) );

		System.out.println("\n (y>>2) is"+ (y>>2) );
		
	}
}

//---------------------------------------------------------------------------------------------------------------------------------

	Associativity and precedence are fundamental concepts in programming that determine how operators 
	are evaluated in expressions.

	Precedence: Precedence refers to the order in which operators are evaluated when multiple operators 
		    are present in an expression. Operators with higher precedence are evaluated first.

	Associativity: Associativity defines the order in which operators with the same precedence are 
		       evaluated. There are two types of associativity:

			1. Left-to-Right (LTR): Operators are evaluated from left to right.
			2. Right-to-Left (RTL): Operators are evaluated from right to left.

Java Operator Precedence and Associativity Table:

Here's a summary of Java operators, their precedence, and associativity:

| Operator        		| Precedence 	| Associativity |
| ---             		| ---       	| ---          	|
| Postfix ([])    		| 1         	| LTR         	|
| Unary (+, -, !) 		| 2         	| RTL          	|
| Multiplicative (*, /, %) 	| 3 		| LTR          	|
| Additive (+, -) 		| 4         	| LTR          	|
| Shift (<<, >>, >>>) 		| 5 		| LTR       	|
| Relational (<, >, <=, >=) 	| 6 		| LTR          	|
| Equality (==, !=) 		| 7 		| LTR          	|
| Bitwise AND (&) 		| 8         	| LTR          	|
| Bitwise XOR (^) 		| 9         	| LTR          	|
| Bitwise OR (|)  		| 10        	| LTR          	|
| Logical AND (&&) 		| 11 		| LTR          	|
| Logical OR (||) 		| 12        	| LTR          	|
| Ternary (? :)  		| 13        	| RTL         	|
| Assignment (=, +=, -=, ...) 	| 14 		| RTL          	|

Examples:

1. Expression: 2 + 3 * 4

Precedence: Multiplication (*) has higher precedence than addition (+).
Evaluation: 2 + (3 * 4) = 2 + 12 = 14

1. Expression: 5 - 3 + 2

Precedence: Subtraction (-) and addition (+) have the same precedence.
Associativity: Left-to-Right.
Evaluation: (5 - 3) + 2 = 2 + 2 = 4

1. Expression: true && false || true

Precedence: Logical AND (&&) has higher precedence than Logical OR (||).
Associativity: Left-to-Right.
Evaluation: (true && false) || true = false || true = true

1. Expression: x = 5 + 3

Precedence: Addition (+) has higher precedence than assignment (=).
Associativity: Right-to-Left.
Evaluation: x = (5 + 3) = x = 8

//---------------------------------------------------------------------------------------------------------------------------------

// Control Statements in Java: 


				Control Statements
					|
			-------------------------------------
			|				    |
		   Conditional				Un-Conditional
			|					|
	------------------------------	        ---------------------------------
	|		|	    |		|	|		|	|
      Decision	      Loop	  case	       break   continue     lbl.break	return
	|		|	    |				    and 
	|- if()		|- for()   switch			    lbl. continue	
	|- if() else	|- while()
	|- nesting	|- do..while()
	|- ladder


//  Decision Conditional Control statment: 

	
	// Using if(): used to decide, execute the block of code or not. That block is mentioned in the program as

			syntax:
				if(<condi>)
				{
					-------------;
					-------------;
					block of code;
					-------------;
					-------------;
				}
				
	- Block of code will be executed only when the condition is true otherwise it will be skipped

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoIf
{
	public static void main(String []args)
	{
		InputStreamReader isr=new InputStreamReader(System.in);
		BufferedReader br=new BufferedReader(isr);

		int a=0;
		try
		{
			System.out.println("Enter the value of a: ");
			a=Integer.parseInt(br.readLine());
		}
		catch(Exception e){}		

		if(a%7==0)
		{
			System.out.println("Entered no is div by 7 ");
		}
		if(a%7!=0)
		{
			System.out.println("Entered no is not div by 7 ");
		}
	}
}

//-----------------------------------------------------------------------------------


	// Using if() else: It is used when you want to execute any one code block from two different blocks
	//		    according to condition.


		syntax:
			if(<condi>)
			{
				-----------------;
				---------------;
				----------------;
			}
			else 
			{
				-----------------;
				---------------;
				----------------;
			}

		when <condi> is  TRUE --> will execute the if() block only
				 FALSE -> will execute the else block only

import java.io.InputStreamReader;
import java.io.BufferedReader;
class DemoIfElse
{
	public static void main(String []args)
	{
		InputStreamReader isr=new InputStreamReader(System.in);
		BufferedReader br=new BufferedReader(isr);

		int a=0;
		try
		{
			System.out.println("Enter the value of a: ");
			a=Integer.parseInt(br.readLine());
		}
		catch(Exception e){}		

		if(a%7==0)
		{
			System.out.println("Entered no is div by 7 ");
		}
		else
		{
			System.out.println("Entered no is not div by 7 ");
		}
	}
}


	// 	Using Nesting of if() else:

			Nesting refers to using one control statment in to same or another control statement


	some combinations:


		if()				if()				if()			if()
		{				{				{			{
			if()				if()			}				if()
			{				{			else				{
			}				}			{				}
		}					else				if()		}
							{				{		else
							}				}		{
						}				}				if()
														{
														}
													}


		
		if()					if()
		{					{
			if()					if()	
			{					{
			}					}
		}						else
		else						{
		{						}
			if()				}
			{				else
			}				{
			else					if()
			{					{
			}					}
		}						else
								{
								}
							}


class DemoIfElseNesting
{
	public static void main(String []args)
	{
		int a=Integer.parseInt(args[0]);
		int b=Integer.parseInt(args[1]);
		int c=Integer.parseInt(args[2]);

		if(a>b)
		{
			if(a>c)
			{
				System.out.println("\n a is max");
			}
			else
			{
				System.out.println("\n c is max");
			}
		}	
		else
		{
			if(b>c)
			{
				System.out.println("\n b is max");
			}
			else
			{
				System.out.println("\n c is max");
			}
		}
	}
}

//---------------------------------------------------------------------------------------------------------------------


	// Using if() else Ladder

	syntax:

		if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		else if(<>)
		{
			---------;
			---------;
		}
		[<else>]
		{
			---------;
			---------;
		}


	// Enter the co-ordinates of point in 2D system, and display the exact location of that point.


			       y axis
                                ^
                       II QD    |   I QD
                                |
                        -+      |   ++
                                |
                  <-------------|------------> x axis
                                |(0,0)
                                |
                        --      |   +-
                                |
                    III QD      V     IV QD



                There are 7 different possibilities.

import java.util.Scanner;
class DemoIfElseLadder
{
	public static void main(String []args)
	{
    		int x=0,y=0;
		Scanner sc=new Scanner(System.in);

    		System.out.println("\n Enter the x cord: ");
    		x=sc.nextInt();
    		System.out.println("\n Enter the y cord: ");
    		y=sc.nextInt();

    		if(x>0&&y>0)
    		{
        		System.out.println("\n Point present in I st qd");
    		}
    		else if(x<0&&y>0)
    		{
        		System.out.println("\n point present in II nd qd");
    		}
    		else if(x<0&&y<0)
    		{
        		System.out.println("\n Point is present in 3 rd qd");
    		}
    		else if(x>0&&y<0)
    		{
        		System.out.println("\n Point is present in 4 th qd");
    		}
    		else if(x!=0&&y==0)
    		{
        		System.out.println("\n Point is present on x axis");
    		}
    		else if(x==0&&y!=0)
    		{
        		System.out.println("\n Point is present on y axis");
    		}
    		else 
    		{
        		System.out.println("\n Point present at org");
    		}
	}
}


------------------------------------------------------------------------------------------------------------------------------------

		// Using the Loops in Java: Loops are used to avoid the continue repitition of code in the program.
					 There are three different loops in C.

				1. For() loop		2. While() loop		3. do..While() loop



	1. For() loop:

		syntax:	
				
			for( [<init>] ; <condi> ; [<inc/dec/stat/expr>] )					
			{									
				--------------;							   
				--------------;						
				--------------;							 
				--------------;							
				--------------;				
			}
		


import javax.swing.JOptionPane;
class DemoFor
{
	public static void main(String []args)
	{
		int no=Integer.parseInt(JOptionPane.showInputDialog("Enterany number:"));
	
		int t=0,tot=0;
		for(t=no;no!=0;no=no/10)
		{
			tot=tot+(no%10); 
		}
		System.out.println("\n Addition of all digits from "+t+" is "+tot");
	}
}

                ///-------------------------------------------------------------------------------------------------------------------------

	//  Using while loop: 

		Again the aim is same i.e. used to avoid the code rep.

		syntax:
			while(<cond>)
			{
				----------------;
				----------------;
				----------------;
				----------------;
				****************;
			}

			- It will execute the body of loop, till the condition is true.

			- <init> block is absent in while() but you have init. the iterator before starting of loop.

			- <inc/dec> block is absent, but you have to add atleast one statement which will make the <cond> false
			  after some iterations. otherwise it will attend the infinite looping


	/// WAP to display 1 to 15 nos using while loop

class DemoWhile
{
	public static void main(String []args)
	{
		int i;

		i=1;
		while(i<=15)
		{
			System.out.println(" "+i);
			i++;
		}
	}
}

//-------------------------------------------------------------------------------------------
	/// WAP to display list of odd nos from 1 to 50 using while loop.

class DemoWhile
{
	public static void main(String []args)
	{
		int i;

		i=1;
		while(i<=50)
		{
			if(i%2!=0)
			{
				System.out.println(" "+i);
			}
			i++;
		}
	}
}

//--------------------------------------------------------------------------


	// WAP to find the entered number is prime

import java.util.*;
class DemoWhile
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter any no: ");
		int no=sc.nextInt();
		int d=2;
		int flg=0;
		while(d<=(no/2))
		{
			if(no%d==0)
			{
				flg=1;
				break;
			}
			d++;
		}
		if(flg==0)
		{
			System.out.println("\n Entered no is prime ");
		}
		else
		{
			System.out.println("\n Entered no is not prime ");
		}
	}
}

//-----------------------------------------------------------------------------------------

	/// using  do while()

	syntax:

	do
	{
		----------;
		----------;
		----------;
		----------;
		----------;
	}while(<cond>);

// Display list of prime nos from given range 

import java.util.*;
class DemoWhile
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("\n Enter the range starts from: ");
		int n1=sc.nextInt();
		System.out.println("\n Enter the range ends to: ");
		int n2=sc.nextInt();

		int d=2,flg=0;
		System.out.println("\n List of prime nos: ");
		for(no=n1;no<=n2;no++)
		{
			d=2;
			flg=0;
			while(d<=(no/2))
			{
				if(no%d==0)
				{
					flg=1;
					break;
				}
				d++;
			}
			if(flg==0)
				System.out.println("  "+no);
		}
	}

//------------------------------------------------------------------------------------------------------------------------------
	
	// WAP to display *

class StarPattern
{
	public static void main(String []args)
	{
		System.out.print("*")
	}
}


class StarPattern
{
	public static void main(String []args)
	{
		System.out.print("*");
	}
}

//-----------------------------------------------------

	WAP to print 
	*****

class StarPattern
{
	public static void main(String []args)
	{
		int j=0;
		for(j=0;j<5;j++)
		{
			System.out.print("*");
		}
	}
}



//-----------------------------------------------------

	WAP to print 
	*****
	*****
	*****
	*****
	*****

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				System.out.print("*");
			}
			System.out.print("\n");
		}
	}
}

//-----------------------------------------------------

	WAP to print 
           j
        01234 
	*****  i=0
	*   *  i=1
	*   *  i=2
	*   *  i=3
	*****  i=4

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<5;i++) // No of lines
		{
			for(j=0;j<5;j++) // no of cols
			{
				if(i==0 || i==4)
				{
					System.out.print("*");
				}
				else if(j==0 || j==4)
				{
					System.out.print("*");
				}
				else
				{
					System.out.print(" ");
				}
			}
			System.out.print("\n");
		}
	}
}

//-------------------------------------------------------------------------------------

	WAP to print 
	* 
	** 
	*** 
	**** 
	*****


class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;

		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				if(j<=i)
				{
					System.out.print("*");	
				}			
			}
			System.out.print("\n");
		}
	}
}



//-----------------------------------------------------

	WAP to print 
	*****
	**** 
	*** 
	** 
	* 

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;

		for(i=0;i<5;i++)
		{
			for(j=0;j<5;j++)
			{
				if(j<(5-i))
				{
					System.out.print("*");	
				}			
			}
			System.out.print("\n");
		}
	}
}

//---------------------------------------------------------------------

		*
	       ***
	      *****
	     *******
	    *********
           *********** 	

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<6;i++)
		{
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print("*");
				}
			}
			System.out.print("\n");
		}
	}
}

//-------------------------------------------------------------------------
 
     1
    222
   33333
  4444444
 555555555
66666666666

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		for(i=0;i<6;i++)
		{
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print(i+1);
				}
			}
			System.out.print("\n");
		}
	}
}

//---------------------------------------------------------------------------------


     A
    ABC
   ABCDE
  ABCDEFG
 ABCDEFGHI
ABCDEFGHIJK

class StarPattern
{
	public static void main(String []args)
	{
		int i, j=0;
		char ch;
		for(i=0;i<6;i++)
		{
			ch='A';
			for(j=0;j<(6+i);j++)
			{
				if(j<(5-i))
				{
					System.out.print(" ");	
				}
				else
				{
					System.out.print(ch);
					ch++;
				}
			}
			System.out.print("\n");
		}
	}
}

//----------------------------------------------------------------------------------------

switch(): It is used in the menu driven programming.

	syntax:
		
		switch(<opt>)
		{
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			case <CC>:
				---------;
				---------;
				break;
			[<default>]:
				-----------;
				----------;
		}
		------------------;


	The switch case is used when there are more possibilities, and from which we have to 
	choose any one according to users choice.


import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println("1.add \n 2.sub \n 3.multi \n 4.div ");
		System.out.println("select your option: ");
		opt=sc.nextInt();

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case 1:
				ans=a+b;
				break;
			case 2:
				ans=a-b;
				break;
			case 3:
				ans=a*b;
				break;
			case 4:
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}

//--------------------------------------------------------------------------------------

	// Using the character as a option (both lcase and ucase for a single case)

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		char opt=0;
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println(" a.add \n b.sub \n c.multi \n d.div ");
		System.out.println("select your option: ");
		opt=sc.nextLine().charAt(0);

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case 'A':
			case 'a':
				ans=a+b;
				break;
			case 'B':
			case 'b':
				ans=a-b;
				break;
			case 'C':
			case 'c':
				ans=a*b;
				break;
			case 'D':
			case 'd':
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}
//-------------------------------------------------------------------------------------------

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int i=0, opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(i<3)
		{
			i++;
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div ");
			System.out.println("select your option: ");
			opt=sc.nextInt();

			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}
//-------------------------------------------------------------------------------------------

	// Using the switch within infinite loop (Termination using break)

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(true)
		{
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div \n 5.stop");
			System.out.println("select your option: ");
			opt=sc.nextInt();

			if(opt==5)
				break;

			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}



//-------------------------------------------------------------------------------------------

	// Using the switch within infinite loop (Termination using System.exit(0) )

import java.util.Scanner;
class DemoSwitch
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int opt=0;
		double a=0.0, b=0.0, ans=0.0;

		while(true)
		{
			System.out.println("\n*** Menu ****");
			System.out.println("1.add \n 2.sub \n 3.multi \n 4.div \n 5.stop");
			System.out.println("select your option: ");
			opt=sc.nextInt();
			System.out.println("Enter any two nos: ");
			a=sc.nextDouble();
			b=sc.nextDouble();
		
			switch(opt)
			{
				case 1:
					ans=a+b;
					break;
				case 2:
					ans=a-b;
					break;
				case 3:
					ans=a*b;
					break;
				case 4:
					ans=a/b;
					break;
				case 5:
					System.exit(0);
				default:
					System.out.println("\n Incorrect Option");			
			}	
			System.out.println("\n Ans is: "+ans);					
		}
	}
}
//---------------------------------------------------------------------------------------

	// We can use string as a case constant.
import java.util.Scanner;
class DemoSwitchStr
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		
		double a=0.0, b=0.0, ans=0.0;

		System.out.println("\n*** Menu ****");
		System.out.println("add \n sub \n multi \n div ");
		System.out.println("select your option: ");
		String opt=sc.nextLine();

		System.out.println("Enter any two nos: ");
		a=sc.nextDouble();
		b=sc.nextDouble();
		
		switch(opt)
		{
			case "add":
				ans=a+b;
				break;
			case "sub":
				ans=a-b;
				break;
			case "multi":
				ans=a*b;
				break;
			case "div":
				ans=a/b;
				break;
			default:
				System.out.println("\n Incorrect Option");			
		}	
		System.out.println("\n Ans is: "+ans);					
	}
}
//---------------------------------------------------------------------------------------

	Unconditional control statements: The control statement does not need any condition.

	NOTE: In Java goto is not present.

	- using the continue: It will keep the enclosing loop in the running condition without
			      considering the remaining body of loop.

class DemoContinue
{
	public static void main(String []args)
	{
		int i,j;

		for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(j>i)
				{
					continue;
				}
				System.out.print("*");
			}
			System.out.println();
		}
	}
}

//-----------------------------------------------------------------------

			  
		// Using Labelled Continue: It will keep loop in running condition, not only
					   enclosing, but outer loops using label(tag)

class DemoLabelledContinue
{
	public static void main(String []args)
	{
		int i,j;

		outer:for(i=0;i<10;i++)
		{			
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(i>5)
				{
					continue outer;
				}
				if(j>i)
				{
					continue;
				}
				System.out.print("*");
			}
			System.out.println();
		}
	}
}		


//-----------------------------------------------------------------------

// Using the break ans labelled break


class DemoBreak
{
	public static void main(String []args)
	{
		int i,j;

		for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(j>i)
				{
					break;
				}
				System.out.print(""+j);
			}
			System.out.println();
		}
	}
}

//----------------------------------------------------------------------------------------------

class DemoLabelledBreak
{
	public static void main(String []args)
	{
		int i,j;

		outer:for(i=0;i<10;i++)
		{
			System.out.print("-");
			for(j=0;j<10;j++)
			{
				if(i>5)
				{
					break outer;
				}
				if(j>i)
				{
					break;
				}
				System.out.print(""+j);
			}
			System.out.println();
		}
	}
}	


//---------------------------------------------------------------------------------------

	// Using return: pass back the value from called method to calling function method.

//===============================================================================================
//===============================================================================================
//===============================================================================================
//===============================================================================================

	// Array in Java

	It is ordered collection of indexed elements having same data type which are
	conti. arranged in the memory.

	Decl. Syntax:
	
		<data_type> <arr_nm>[];		<data_type> []<arr_nm>;	

		e.g.
		int ar[];			int []ar;

	* Note 
		- In this decl, <element_count> is absent.
		- Above decl. creates the reference only.(same as pointer variable in C)

		In above both cases,

		ar
		 [  ]


	To allocate the memnory we need to use new keyword as..

		- Syntax
			<data_type> []<arr_nm> = new <data_type>[<size>];

			e.g.
				int []ar = new int[5];

			ar
			[   ] ----------------> [] [] [] [] []

	* Note that, Here in java array gains the dynamic memory space(like pointer in C), and
	  new keyword used to allocate the memory for it.

	// Init of array in java

	It is simple and same as we have seen in the C-C++, except [] does not contains the SIZE.

	e.g.
		int []x = {12,45,83,42,39};

		x            0    1    2    3    4 
		[ ] ------> [12] [45] [83] [42] [39]

	// WAP to init and display the array.

class InitArray
{
	public static void main(String []args)
	{
		int []x = {12,45,83,42,39,78};

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<6 ; i++)
		{
			System.out.print("   "+x[i]);
		}

		System.out.println("\n2. Array elements are: ");
		for(int i=0 ; i<x.length ; i++)
		{
			System.out.print("   "+x[i]);
		}

		// using for-each loop
		System.out.println("\n3. Array elements are: ");
		for(int val : x)
		{
			System.out.print("   "+val);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using BufferedReader and InputStreamReader

import java.io.*;
class ArrayIOBI
{
	public static void main(String []args) throws Exception
	{
		int []ar = new int[5];

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=Integer.parseInt(br.readLine());
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using Scanner

import java.util.Scanner;
class ArrayIOSI
{
	public static void main(String []args) 
	{
		int []ar = new int[5];

		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=sc.nextInt();
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - using Commandline arguments

import java.util.Scanner;
class ArrayIOSI
{
	public static void main(String []args) 
	{
		int []ar = new int[5];

		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<5 ; i++)
		{
			ar[i]=sc.nextInt();
		}

		System.out.println("\n1. Array elements are: ");
		for(int i=0 ; i<ar.length ; i++)
		{
			System.out.print("   "+ar[i]);
		}
	}
}

//-----------------------------------------------------------------------------------

	Array input and display - showInputDialog()

import javax.swing.JOptionPane;
class ArrayIOSIDialog
{
	public static void main(String []args) 
	{
		String data = JOptionPane.showInputDialog("Enter the Space seperated array of integers");
		System.out.println("Entered string: "+data);

		String []nums = data.split(" ");
		int []ar = new int[nums.length];		

		System.out.println("\n Enter array: ");
		for(int i=0 ; i<nums.length ; i++)
		{
			ar[i]=Integer.parseInt(nums[i]);
		}

		System.out.println("\n1. Array elements are: ");
		for(int x : ar)
		{
			System.out.print("    "+x);
		}
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Dynamic Memory Allocation ( Using java array as a pointer)

import java.util.Scanner;
class DynamicAllocation
{
	public static void main(String []args)
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter the Element count: ");
		int cnt=sc.nextInt();
		int []a = new int[cnt];

		System.out.println("Enter the "+cnt+" Elements: ");
		for(int i=0;i<cnt;i++)
		{
			a[i]=sc.nextInt();
		}

		System.out.println("Elements: ");
		for(int t : a)
		{			
			System.out.println("  "+t);
		}
	}
}

//---------------------------------------------------------------------------------------------
	
	// Some Array Operations

	 - search
	 - sort
	 - sortrange
	 - insert
	 - delete
	 - reverse
	 - copy
	 - copyrange
	 - Reverse Copy
	 - merge
	 - split
	 - concate
	 - compare
	 - fill
	 - fillrange

//---------------------------------------------------------------------------------------------
	
	// Characher Array in Java:

		decl. syntax:
		
			char []<ar_nm>;
			e.g.
				char []ch;	// creates reference only
				char []ch={'H','e','l','l','o'}; // init of character array

	Note that in java input is not inform of characters, it is in form of String. so no any
	special way is there to input the character array. The class String used to represent the
	character coection in its equivalent object form, having one method names toCharArray(),
	used to convert string into character array.

	here character array and String are different

	*What is difference between character array and String?

import java.util.*;
class DemoCharArray
{
	public static void main(String []args)
	{
		char []ch;	// creates reference only
		char []ch1={'H','e','l','l','o'}; // init of character array

		Scanner sc = new Scanner(System.in);

		System.out.print("\n Enter the any string: ");
		String str=sc.nextLine();
		
		System.out.println("Entered String: "+str);

		ch=str.toCharArray();
		System.out.println("Converted String: ");

		for(char t : ch)
		{
			System.out.print(" "+t);
		}
	}
}

//--------------------------------------------------------------------------------------------------------

	Multi-dimentional Array: Collection of references to another arrays.

	<data_type> [][]<ar_ name>;	-->	int [][]ar;

						  ar
						   [ ]

	memory allocation:
						
	<data_type> [][]<ar_ name> = new <data_type>[rows][cols] ;

	case 1:	int [][]ar;

			ar
			[  ]

		
	case 2:	int [][]ar = new int[3][];

			ar
			[  ] -------->  [ ]
					[ ]
					[ ]


		
	case 3:	int [][]ar = new int[3][4];

			ar								ar
			[  ] -------->  [ ]------>[][][][]				[  ] ----> [][][][]
					[ ]------>[][][][]     Simply it is refered as 		   [][][][]
					[ ]------>[][][][]					   [][][][] 
							       ans can be accessed as ar[i][j]	

	// init. of 2D Array:

class Init2dArray
{
	public static void main(String []args)
	{
		int [][]ar = { {12,34,45,56}, {11,22,33,44}, {10,20,30,40} };

		System.out.println("Array elements are");
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<4;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
		System.out.println("\n Array elements are");
		for(int i=0;i<ar.length;i++)
		{
			for(int j=0;j<ar[i].length;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
	}
}
//----------------------------------------------------------------------------------------
	// input and display 2D Array of 3x4

import java.util.Scanner;
class Init2dArray
{
	public static void main(String []args)
	{
		int [][]ar = new int[3][4];
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the Array elements");
		for(int i=0;i<3;i++)
		{
			for(int j=0;j<4;j++)
			{
				ar[i][j] = sc.nextInt();
			}
		}
		System.out.println("\n Array elements are");
		for(int i=0;i<ar.length;i++)
		{
			for(int j=0;j<ar[i].length;j++)
			{
				System.out.print("  "+ar[i][j]);
			}
			System.out.println();
		}
	}
}

///--------------------------------------------------------------------------------------

	// WAP to perform matrix multi.

import java.util.Scanner;
class Array2DMulti
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		int [][]x=new int[3][3];
		int [][]y=new int[3][3];
		int [][]z=new int[3][3];
		int i,j,k;

		System.out.println("Enter array of 3x3: \n");
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				x[i][j]=sc.nextInt();
			}
			System.out.println();
		}

		System.out.println("Enter another array of 3x3: \n");
		for(i=0;i<3;i++)
		{
			for(j=0;j<3;j++)
			{
				y[i][j]=sc.nextInt();
			}
			System.out.println();
		}

		// multi.
		for(i=0;i<x.length;i++)
		{
			for(j=0;j<x[i].length;j++)
			{
				z[i][j]=0;
				for(k=0;k<x[i].length;k++)
				{
					z[i][j]=z[i][j]+(x[i][k]*y[k][j]);
				}
			}
		}
		
		System.out.println("\n Array elements are: \n");
		for(i=0;i<x.length;i++)
		{
			for(j=0;j<x[i].length;j++)
			{
				System.out.print("  "+x[i][j]);
			}
			System.out.print("\t");
			for(j=0;j<y[i].length;j++)
			{
				System.out.print("  "+y[i][j]);
			}
			System.out.print("\t");
			for(j=0;j<z[i].length;j++)
			{
				System.out.print("  "+z[i][j]);
			}
			System.out.println();
		}
	}
}
///-----------------------------------------------------------------------------------------

 // Different operations of matrix:

	- Tranpose
	- unit matrix
	- upper triangular
	- lower triangular
	- diagonal
	
///-----------------------------------------------------------------------------------------

	// Variable size Array or Jagged Array

	suppose, you decl. an array as,

		int [][]x=new int[3][];

	then see the memory map is as shown below,

		x
		[ ] --------->  [ ]
				[ ]
				[ ]
			  These all 3 are the references, which will able to refer
			  dynamically created location of correct type, having any SIZE. 

	Means to store data, we need to allocate memory for each location. So we need to
	write it as,
	
		x[0]=new int[5];
		x[1]=new int[7];
		x[2]=new int[4];

		x
		[ ] --------->  [ ] -------> [][][][][]
				[ ] -------> [][][][][][][]
				[ ] -------> [][][][]

	So Note that, In Jagged array(variable size array) size(length) of every row
	may be different.

lets see the example.

	We have to create a 2D array to store runs of N player scored in M matches. where
	M may be different for each player.

import java.util.Scanner;
class DemoJagged
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the player count: ");
		int pcnt = sc.nextInt();
		int [][]data = new int[pcnt][];

		System.out.println("\n Enter the details of "+pcnt+" Players");
		for(int i=0;i<data.length;i++)
		{
			System.out.println("\n Enter the march count of player "+(i+1)+": ");
			int mcnt=sc.nextInt();
			data[i] = new int[mcnt];
			System.out.println("\n Enter the runs scored by player: ");
			for(int j=0;j<data[i].length;j++)
			{
				System.out.println("\n Match "+(j+1)+": ");
				data[i][j]=sc.nextInt();
			}
		}

		System.out.println("\n Score Board");

		int i=1;
		for(int []p : data)
		{
			System.out.print("\n Player "+(i++)+": ");
			for(int r : p)
			{
				System.out.print("  "+r);
			}
			System.out.println();
		}
	}
}

//-----------------------------------------------------------------------------------------------------------

	// POINTER - EXPLICIT POINTER IS NOT PRESENT IN JAVA, COZ ITS NEED ALREADY FULLFILLED BY ARRAY.
		     BUT AS OBJECT GAINS THE DYNAMIC MEMORY SPACE, IMPLICITELY IT IS HANDLED BY POINTER.
		     SO IT IS NOT PRESENT FOR AS A PROGRAMMER.


		- Why pointer is not present in java?


//===================================================================================================================

	// OOPs in Java

	What we have seen in C++,

	- Fundamantals - class, Object, Data Hiding, Encapsulation, Abstraction
	- Methods - Method Overloading,and Overriding
	- Static members (static variables, and static methods)
	- constructors and destructors
	- Inheritance: single, multi-level, Multiple, Hierarchical, Hybrid, virtual base class
	- Polymorphism - virtual function, pure virtual function, abstract class.
	- Operator Overloading


	// Fundamantals of Object Oriented Programming:

	  1. class: It is user defined data type, which allows you to define a type using data member(instance
		   variables) and member functions(Methods). It is just blueprint, which divides the members
		   in the private, protected, public and default(No keyword) visibility mofifiers.

		Syntax:
			class <class_name>
			{
				<visibility> <data_type> <var_nm>;
				<visibility> <return_type> <method_nm>();
				.......
			}

		e.g.
			class Demo
			{
				private int x;
				private double y;
				float z;
				public void input() {......}
				public void display() {......}
			}

		*Note: Remember that, visibility modifier must be used as a type qualifier for each member,
		       Absence of any keyword it will be considered as default.	and unlike C++, class does not 
		       ends with ;

	The visibility of class members in Java:	
	
	 - private:   member is only accessible within the same class.
	 - protected: member is accessible within its own package and by subclasses form same of different packages
	 - public: member is accessible from any class, both inside and outside the package.
	 - default / Package-Private (no modifier)class member is accessible only within its own package.
	
	2. Object: It is variable of class type or we can define it as it is standard implementation of class.
		or can be defined as, It is runtime entity - which encapsulates the data and code used to
		process that data.

		Syntax:
			<class_nm> <object_nm> = new <class_constructor>();

	*Note that, C++ style decl. creates the REFERENCE VARIABLE only(like a pointer variable).

	 i.e.
		Demo ob;		ob
					 [  ]

		Demo ob = new Demo();	
		
		 ob
		 [  ] -------> [ Memory allocated for object ] 


	** There is one unwritten rule, which recommanded for programmers and it is followed in
	   java internally while designing the library.

		- Method Names Should Be Verb-Phrase that describes what the method does.
		- Method names should start with a lowercase letter, and each subsequent word should start 
		  with an uppercase letter. This is called lower camel case.
		  e.g.
			calculateTotal(), sendEmail(), getUserDetails(), setAccountBalance()

		- Constants are typically written in uppercase letters with words separated by underscores (_), 
		  a style known as screaming snake case.
		  e.g.
			MAX_WIDTH, PI, DEFAULT_TIMEOUT

		- Class names should follow Upper Camel Case (also called Pascal Case), where the first letter 
		  of each word is capitalized and there are no spaces or underscores.
		  e.g.
			Person, EmployeeDetails, AccountManager
			

	3. data hiding: The private data of class is not accessible directly using the dot
			operator, means that data is get hided from outside world, which is
			known as data hiding.  
				
			The Data Hiding provides the security to data.

	4. Encapsulation: Wrapping up of data members and member functions together under
			  single unit is known as encapsulation. 

			Here in class the data member and member functions are encapsulated together.
				
	5. Abstraction: In simple words "Without knowing too much about it"
			It is an art of defining the new type(class) without including its background details.

			here in case of class and object, we dont think about the amount of
			memory as well as its representation in the memory(memory map), means
			we are abstract about it.

			The data types which supports abstraction known as Abstract Data Types (ADT)


//---------------------------------------------------------------------------------------------------------------------


	ob
	 [  ] -------> [------------------]

class Demo
{
	private int x;
	public void in(){
		x=100;
	}
	public void out(){
		System.out.println("x="+x);
	}
}
class MainClass
{
	public static void main(String []args)
	{
		Demo ob = new Demo();

		ob.in();
		ob.out();
	}
}

//-------------------------------------------------------------------------

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails()
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();

		System.out.println("Enter the height: ");
		hig=sc.nextDouble();
	}
	public void showPersonDetails()
	{
		System.out.println("Name: "+name+"\t Age: "+age+"\t Height: "+hig);
	}	
}

class MainClassExample
{
	public static void main(String []args)
	{
		Person p1 = new Person();
		p1.setPersonDetails();
		p1.showPersonDetails();

		Person p2 = new Person();
		p2.setPersonDetails();
		p2.showPersonDetails();
	}
}


//------------------------------------------------------------------------------
	
	// We can write same program as

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails(String nm, int ag, double h)
	{
		name=nm;
		age=ag;
		hig=h;
	}
	public void showPersonDetails()
	{
		System.out.println("Name: "+name+"\t Age: "+age+"\t Height: "+hig);
	}	
}

class MainClassExample1
{
	public static void main(String []args)
	{

		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		String name=sc.nextLine();
		System.out.println("Enter the age: ");
		int age=sc.nextInt();
		System.out.println("Enter the height: ");
		double hig=sc.nextDouble();

		Person p1 = new Person();
		p1.setPersonDetails(name, age, hig);
		
		System.out.println("Enter the name: ");
		name=sc.nextLine();
		System.out.println("Enter the age: ");
		age=sc.nextInt();
		System.out.println("Enter the height: ");
		hig=sc.nextDouble();

		Person p2 = new Person();
		p2.setPersonDetails(name, age, hig);


		p1.showPersonDetails();
		p2.showPersonDetails();
	}
}

//-----------------------------------------------------------------------------------------

	// Again can be written as

import java.util.Scanner;
class Person
{
	private String name;
	private int age;
	private double hig;
	public void setPersonDetails()
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the name: ");
		name=sc.nextLine();

		System.out.println("Enter the age: ");
		age=sc.nextInt();

		System.out.println("Enter the height: ");
		hig=sc.nextDouble();
	}
	public String getName()
	{
		return name;
	}
	public int getAge()
	{
		return age;
	}	
	public double getHeight()
	{
		return hig;
	}
}

class MainClassExample3
{
	public static void main(String []args)
	{
		Person p1=new Person();
		p1.setPersonDetails();

		Person p2=new Person();
		p2.setPersonDetails();

		System.out.println("Name: "+p1.getName()+"\t Age: "+p1.getAge()+"\t Height: "+p1.getHeight());
		System.out.println("Name: "+p2.getName()+"\t Age: "+p2.getAge()+"\t Height: "+p2.getHeight());
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Write a class Number to hold one int value and arrange some methods to process that int value.

import java.util.Scanner;
class Number
{
	private int no;
	public void setNumber(int n) 
	{
		no=n;
	}
	public int getNumber()
	{
		return no;
	}
	public int findReverse()
	{
		int n=no;

		int rev=0;
		while(n!=0)
		{
			rev = (rev*10) + (n%10);
			n = n/10;
		}
		return rev;
	}
	public char isPalindrome()
	{
		if(no==findReverse())
			return 'y';
		else
			return 'n';
	}
	public String isEvenOrOdd()
	{
		if(no%2==0)
			return "even";
		else
			return "odd";
	}
	public void isPrime()
	{	
		int d=2,flg=0;
		while(d<=(no/2))
		{
			if(no%d==0)
			{
				flg=1;
				break;
			}
			d++;
		}
		if(flg==0)
			System.out.println("Number is Prime");
		else
			System.out.println("Number is not Prime");
	}
	public int findMax(int h)
	{
		int ans = (no>h) ? no : h;
		return ans;
	}
}

class DemoNumber
{
	public static void main(String []args)
	{
		Number nob = new Number();

		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the Number: ");
		int t=sc.nextInt();

		nob.setNumber(t);

		System.out.println("\n Number is: "+nob.getNumber());

		int r = nob.findReverse();
		System.out.println("\n Reverse Number is: "+r);

		char ans=nob.isPalindrome();
		if(ans=='y')
			System.out.println("\n Number is Palindrome");
		else
			System.out.println("\n Number is Not Palindrome");

		System.out.println("\n Number is: "+nob.isEvenOrOdd());

		nob.isPrime();

		System.out.println("Enter the Number: ");
		int k=sc.nextInt();

		int max=nob.findMax(k);
		System.out.println("max Number: "+max);
	}
}

//------------------------------------------------------------------------------------------------------------		

	// Write a program to represent an array as a object and perform some operations on that array object.

import java.util.Scanner;
class MyArray
{
	private int []x;
	public void fill(int t)
	{
		x=new int[5];
		for(int i=0;i<x.length;i++)
		{
			x[i]=t;
		}
	}
	public void in()
	{
		Scanner sc = new Scanner(System.in);
		System.out.print("\n Enter element count: ");
		int k=sc.nextInt();
		x=new int[k];
		 
		System.out.print("Enter the "+k+" Elements: ");
		for(int i=0;i<k;i++)
		{
			x[i] = sc.nextInt();
		}
	}
	public void out()
	{
		System.out.print("\n Elements are: ");
		for(int val : x)
		{
			System.out.print("   "+val);
		}
	}
	public int search(int t)
	{
		for(int i=0;i<x.length;i++)
		{
			if(x[i]==t)
				return i;
		}
		return -1;
	}
}
class MyArrayExample
{
	public static void main(String[] args) 
	{
		MyArray ob = new MyArray();
		ob.fill(3);
		ob.out();

		ob.in();
		ob.out();

		Scanner sc = new Scanner(System.in);
		System.out.println("\n Enter the element to be searched: ");
		int n=sc.nextInt();
		int pos = ob.search(n);
		if(pos==-1)
			System.out.println("\n Number is not present in an array");
		else
			System.out.println("\n Number is present at "+pos+" position");
	}
}

//--------------------------------------------------------------------------------------

	// Create the class employee and just input and display the employee data.

import java.io.BufferedReader;
import java.io.InputStreamReader;
class Employee
{
	private int id;
	private String name;
	private double sal;
	public void inputInformation() throws Exception
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		System.out.println("Enter the Name: ");
		name=br.readLine();
		
		System.out.println("Enter the id: ");
		id=Integer.parseInt(br.readLine());

		System.out.println("Enter the salary: ");
		sal=Double.parseDouble(br.readLine());
	}
	public void showInformation()
	{
		System.out.println("Employee Name: "+name+"\t ID: "+id+"\t Salary: "+sal);
	}	
}

class MainClassEmployee
{
	public static void main(String []args) throws Exception
	{
		Employee e1=new Employee();

		e1.inputInformation();
		e1.showInformation();
	}
}

//-----------------------------------------------------------------------------------------------------------

	// Creating Anonymous Object:

	Anonymous Object is an instance of class which can not be refered by any referance variable 
	when it is created. we are able to call the methods from same instance only once at the time
	of decl.
	It's often used for situations where you only need an object temporarily, without the need to store 
	or reuse it. You cannot refer to or modify the object later since it is not stored in a variable.

class DemoObj
{
	public void show()
	{
		System.out.println("\n In the DemoObj-show()");
	}
}

class MainDemoObj
{
	public static void main(String []args)
	{
		// Creating Anonymous Object
		new DemoObj().show();
		new DemoObj().show();
	}
}


//------------------------------------------------------------------------------------------------

	// Defining main() method in same class

class DemoMainSameClass
{
	private int x=1;
	private double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		System.out.println("\n x="+x);
		System.out.println("\n y="+y);

		System.out.println("\n main() end");
	}
}

---------- On Compile ---------------
Y:\jsmall>javac DemoMainSameClass.java
DemoMainSameClass.java:9: error: non-static variable x cannot be referenced from a static context
                System.out.println("\n x="+x);
                                           ^
DemoMainSameClass.java:10: error: non-static variable y cannot be referenced from a static context
                System.out.println("\n y="+y);
                                           ^


// Now i want to create multiple instances

	 Note that if you want to access the members of class where main() is defined then also you need to 
  	 create the object of same class and access the methods.
	 

class DemoMainSameClass
{
	private int x=1;
	private double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		DemoMainSameClass ob1 = new DemoMainSameClass();
		System.out.println("\n ob1.x="+ob1.x);
		System.out.println("\n ob1.y="+ob1.y);
		
		DemoMainSameClass ob2 = new DemoMainSameClass();
		System.out.println("\n ob2.x="+ob2.x);
		System.out.println("\n ob2.y="+ob2.y);

		System.out.println("\n main() end");
	}
}


// another ways is decl thode variables as static

class DemoMainSameClass
{
	private static int x=1;
	private static double y=2.2;
	public static void main(String []args)
	{
		System.out.println("\n main() started");
		
		System.out.println("\n x="+x);
		System.out.println("\n y="+y);

		System.out.println("\n main() end");
	}
}

//-----------------------------------------------------------------------------

	// Defining methods within main() class

class DemoMainMethod
{
	public void sampleMethod()
	{
		System.out.println("\n In sampleMethod()");
	}
	public static void main(String []args)
	{
		System.out.println("\n main() starts");
		sampleMethod();
		System.out.println("\n main() end");
	}
}

 ------------- On Compile -----------------

Y:\jsmall>javac DemoMainMethod.java
DemoMainMethod.java:10: error: non-static method sampleMethod() cannot be referenced from a static context
                sampleMethod();
                ^
1 error

	Solution: 
	- Decl. sampleMethod() method as static	OR
	- Create an object of class DemoMainMethod and call sampleMethod()


//---------------------------------------------------------------------------------------------------

	// WAP to input and display the data of two students

import java.util.Scanner;
class Student
{
	private int id;
	private double per;

	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the student ID: ");
		id=sc.nextInt();

		System.out.println("Enter the Percentage: ");
		per=sc.nextDouble();
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Student s1=new Student();
		s1.in();
		s1.out();

		Student s2=new Student();
		s2.in();
		s2.out();
	}
}	

//--------------------------------------------------------------

	// Or can be passed from the main()

import java.util.Scanner;
class Student
{
	private int id;
	private double per;

	public void in(int t1, double t2)
	{
		id=t1;
		per=t2;
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);

		System.out.println("Enter the student ID: ");
		int sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		double sper=sc.nextDouble();

		Student s1=new Student();
		s1.in(sid,sper);
		s1.out();

		//-----------------------------------------------

		System.out.println("Enter the student ID: ");
		sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		sper=sc.nextDouble();

		Student s2=new Student();
		s2.in(sid,sper);
		s2.out();
	}
}	

//------------------------------------------------------------------------------------------------------

	// Method overloading with class

	Method overloading in Java allows you to define multiple methods with the same name but different parameter
	lists. It increases the flexibility, readability, and maintainability of your code. Just remember that
	overloading depends on differences in the method signatures (the method name and parameters), not the 
	return type, and visibility.

import java.util.Scanner;
class Student
{
	private int id;
	private double per;
	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter the student ID: ");
		id=sc.nextInt();

		System.out.println("Enter the Percentage: ");
		per=sc.nextDouble();
	}
	public void in(int t1, double t2)
	{
		id=t1;
		per=t2;
	}
	public void out()
	{
		System.out.println("\n Student ID: "+id+"\n Percentage: "+per);
	}
}
class DemoStudent
{
	public static void main(String []args)
	{
		Scanner sc=new Scanner(System.in);
		
		Student s1=new Student();
		s1.in();
		s1.out();
		//-----------------------------------------------

		System.out.println("Enter the student ID: ");
		sid=sc.nextInt();
		System.out.println("Enter the Percentage: ");
		sper=sc.nextDouble();
		Student s2=new Student();
		s2.in(sid,sper);
		s2.out();
	}
}	


	In above program, there are two different copies of in() method i.e.

		public void in()
		public void in(int t1, double t2)

	as a class contains two copies of function having same name and differ in terms of
	signature, it is known as "Method Overloading"

//---------------------------------------------------------------------------------------------------------

	// Lets discuss the class by value and class by refernce.

	- We know that, In C++, variable are passed by value bydefault. If you want to pass them
	  byreference then pointer is used.

class SwapDemo
{
	public static void swap(int a, int b)
	{
		int tmp;
		tmp=a;
		a=b;
		b=tmp;
	}
	public static void main(String[]args)
	{
		int x=10, y=20;
		System.out.println("\n Before Interchange x="+x+"\t y="+y);
		swap(x,y);
		System.out.println("\n After Interchange x="+x+"\t y="+y);
	}
}

 ----- Output -------
Y:\jsmall>javac SwapDemo.java
Y:\jsmall>java SwapDemo
 Before Interchange x=10   y=20
 After Interchange x=10  y=20

	Means java variables are passed by value bydefault. Then how to pass the byreference coz, in c++,
	pointer is used, here in java pointer is absent.

	solution is that, pass the values in form of object, coz object bydefault passesd by reference.
	for that,
	 - create custom class to reperent the int value in its equivalent object from. OR
	 - User wrapper classes.


	// Lets first confirm that, Object is bydefault passed by reference.

class Int
{
	private int data;
	public void setData(int data)
	{
		this.data=data;
	}
	public int getData()
	{
		return data;
	}
}
class ObjByRefConfirm
{
	public static void sample(Int t)
	{
		t.setData(t.getData()+100);
	}
	public static void main(String[]args)
	{
		int x=10;
		Int obx = new Int();
		obx.setData(x);

		System.out.println("Before - x="+obx.getData());
		sample(obx);
		System.out.println("After - x="+obx.getData());		
	}
}

 --- Output ----

Y:\jsmall>javac ObjByRefConfirm.java

Y:\jsmall>java ObjByRefConfirm
Before - x=10
After - x=110

	It is confirmation, that Object passed by reference.
//--------------------------------------------------------------------------------------------

	// Use same class for swapping (Using custom class)

class Int
{
	private int data;
	public void setData(int data)
	{
		this.data=data;
	}
	public int getData()
	{
		return data;
	}
	public String toString()
	{
		return ""+data;
	}
}
class SwapDemoUsingObj
{
	public static void swap(Int oba, Int obb)
	{
		int tmp;
		tmp=oba.getData();
		oba.setData(obb.getData());
		obb.setData(tmp);
	}
	public static void main(String[]args)
	{
		int x=10, y=20;

		Int obx = new Int();
		obx.setData(x);

		Int oby = new Int();
		oby.setData(y);

		System.out.println("\n Before Interchange x="+obx+"\t y="+oby);
		swap(obx,oby);
		System.out.println("\n After Interchange x="+obx+"\t y="+oby);
	}
}

 ----- output -----

 Before Interchange x=10         y=20

 After Interchange x=20  y=10
Press any key to continue . . .

//----------------------

	Another way to represent the data in its equivalent object from is to use Wrapper classes

class SwapDemoUsingObjUsingWrapper
{
	public static void swap(Integer  oba, Integer obb)
	{
		int tmp;
		tmp=oba;
		oba=obb;
		obb=tmp;
	}
	public static void main(String[]args)
	{
		int x=10, y=20;

		Integer obx = x;
		Integer oby = y;

		System.out.println("\n Before Interchange x="+obx+"\t y="+oby);
		swap(obx,oby);
		System.out.println("\n After Interchange x="+obx+"\t y="+oby);
	}
}


The output will not gives the swaped values coz Integer object is immutable. You need mutable object
or use the array. 

	The values of x and y are not swapping because:

	- Java passes object references by value.
	- The swap method only modifies the local copies of the references.
	- Integer objects are immutable, so their values cannot be changed directly.

	NOTE:
	- When you pass a primitive type (e.g., int, float, char) to a method, a copy of the value is 
	  passed. Changes made to the parameter inside the method do not affect the original variable.

	- When you pass an object to a method, a copy of the reference to the object is passed. This 
	  means that the method receives a reference to the same object, but the reference itself is a copy.
	
	- Changes made to the object through the reference inside the method will affect the original object. 
	  However, changes made to the reference itself (e.g., assigning it to a new object) will not affect 
	  the original reference.


	// Using the array to swap the value

public class SwapDemoUsingArray {
    public static void swap(int[] arr) {
        int tmp = arr[0];
        arr[0] = arr[1];
        arr[1] = tmp;
    }

    public static void main(String[] args) {
        int x = 10, y = 20;

        int[] arr = {x, y};

        System.out.println("\n Before Interchange x=" + arr[0] + "\t y=" + arr[1]);
        swap(arr);
        System.out.println("\n After Interchange x=" + arr[0] + "\t y=" + arr[1]);
    }
}


//------------------------------------

	What is a POJO Class in java?
	 - A POJO (Plain Old Java Object) is a simple object in Java that doesn't adhere to any special restriction 
	  other than those forced by the Java Language Specification and does not require any classpath. 
	  Here are the key points that define a POJO class:

	- No Implements: It does not implement any special interfaces such as Serializable, Externalizable, etc.
	- No Extends: It does not extend prespecified classes which may force it to behave in a certain way.
	- Simple Fields: Fields should be private to achieve encapsulation. Fields can be accessed directly 
	  via getters and setters.
	- Zero-arg Constructor: Often includes a no-argument constructor.

public class Person {
    private String name;
    private int age;

    public Person() {
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Employee{name='" + name + "', Age=" + age + "}";
    }
}

//-----------------------------------------------------------------------------------------------------------

	// Constructors in Java Classes: 

	 A constructor in Java is a special method used to initialize objects when they are created. It has the same 
	 name as the class and does not have a return type (not even void). Constructors are automatically called when 
	 an object of the class is instantiated.You can define multiple constructors with different parameters 
	 (constructor overloading).

	Types of Constructors:
	  - Default Constructor (No-Argument Constructor):
	  - Parameterized Constructor:
	  - Copy Constructor (Not built-in like in C++):


	// Default Constructor (No-Argument Constructor): It is constructor without arguments. Can init.
	   instance variables using input or using literals. In absence of constructor in class, the default 
	   constructor with the empty body will be provided by the compiler itself. 

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		x=10;
		y=23.45;
		System.out.println("\n In default constructor of Sample class");
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainDefaultex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();
	}
}


//--------

	// Default constructor can take the values from keyboard

	
class Sample
{
	private int x;
	private double y;
	public Sample()
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainDefaultex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();
	}
}

//--------------------------------------------------------------------------------------------------------

	- Parameterized Constructor: It is the constructors with arguments.

	 * If we define any constructor in class then it is our responsibility to define default constructor,
	   in such case compiler will not provide the default constructor with empty body. In absence of default 
	   constructor the error will be generated only when compiler will need it for allocation.
	 * A call may contain multiple constructors, but only one executed at a time.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In Default constructor of Sample class");
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor of Sample class");
		x=a1;
		y=a2;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class Mainparaex
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12,89.45);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();
	}
}

//---------------------------------------------------------------------------------------------

	Constructor Overloading: Defining multiple constructors in a same class. Only take case that
	there must not be two or more construcctors with same signature.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public Sample(int a) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-1 of Sample class");
		x=a;
		y=a;
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-2 of Sample class");
		x=a1;
		y=a2;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainConOverloading
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();
	}
}

//-----------------------------------------------------------------------------------------------

	Copy Constructor: A constructor used to create a new object by copying an existing object's data.

class Sample
{
	private int x;
	private double y;
	public Sample() // Default constructor
	{
		System.out.println("\n In default constructor of Sample class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		x=sc.nextInt();
		System.out.println("Enter the double value: ");
		y=sc.nextDouble();
	}
	public Sample(int a) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-1 of Sample class");
		x=a;
		y=a;
	}
	public Sample(int a1, double a2) // Parameterized constructor
	{
		System.out.println("\n In Para constructor-2 of Sample class");
		x=a1;
		y=a2;
	}
	public Sample(Sample t) // copy constructor
	{
		System.out.println("\n In copy constructor of Sample class");
		x=t.x;
		y=t.y;
	}
	public void showData()
	{
		System.out.println("\n x="+x+"\t y="+y);
	}
}
class MainConCopy
{
	public static void main(String []args)
	{
		Sample ob = new Sample();
		ob.showData();

		Sample ob2 = new Sample(12);
		ob2.showData();

		System.out.println("\n In Main class");
		java.util.Scanner sc = new java.util.Scanner(System.in);
		System.out.println("Enter the int value: ");
		int x=sc.nextInt();
		System.out.println("Enter the double value: ");
		double y=sc.nextDouble();
		Sample ob3 = new Sample(x,y);
		ob3.showData();

		Sample ob4 = new Sample(ob3);
		ob4.showData();
	}
}

//--------------------------------------------------------------------------------------------------------

	Constructor chaining: 
	
	Constructor chaining in Java refers to the process of calling one constructor 
	from another within the same class or in a superclass. It allows you to reuse code by having one
	constructor invoke another, reducing redundancy and ensuring consistent initialization of an object.

	- Within the Same Class (Using this()):
		A constructor calls another constructor of the same class.

	- From a Superclass (Using super()):
		A subclass constructor calls a constructor of its superclass.
	
public class DemoChainCon {
    private String name;
    private int age;
    private String grade;

    // Default constructor
    public DemoChainCon() {
        this("Unknown", 0, "Not Assigned");  // Calls the parameterized constructor
		System.out.println("\n Default constructor of DemoChainCon class");
    }

    // Constructor with two parameters
    public DemoChainCon(String name, int age) {
        this(name, age, "Not Assigned");  // Calls the constructor with three parameters
		System.out.println("\n Para(args-2) constructor of DemoChainCon class");
    }

    // Parameterized constructor with three parameters
    public DemoChainCon(String name, int age, String grade) {
		System.out.println("\n Para(args-3) constructor of DemoChainCon class");
        this.name = name;
        this.age = age;
        this.grade = grade;
    }

    public void display() {
        System.out.println("Name: " + name + ", Age: " + age + ", Grade: " + grade);
    }

    public static void main(String[] args) {
        DemoChainCon s1 = new DemoChainCon();  // Calls default constructor
        DemoChainCon s2 = new DemoChainCon("Amol", 20);  // Calls two-parameter constructor
        DemoChainCon s3 = new DemoChainCon("Baba", 22, "A");  // Calls three-parameter constructor

        s1.display();  // Output: Name: Unknown, Age: 0, Grade: Not Assigned
        s2.display();  // Output: Name: Alice, Age: 20, Grade: Not Assigned
        s3.display();  // Output: Name: Bob, Age: 22, Grade: A
    }
}

	** Note: this() must be first statement in constructor while chaining.


//--------------------------------------

	Constructor Chaining Between Superclass and Subclass:
		You use the keyword super() to call the constructor of the superclass.

class A
{
	int a;
	public A()
	{
		System.out.println("\n In default constructor of A class");
		a=10;
	}
	public A(int a)
	{		
		System.out.println("\n In para constructor of A class");
		this.a=a;
	}
	public void showa()
	{
		System.out.println("\n a="+a);
	}
}
class B extends A
{
	int b;
	public B()
	{
		System.out.println("\n In default constructor of B class");
		b=20;
	}
	public B(int a, int b)
	{		
		super(a);
		System.out.println("\n In para constructor of B class");
		this.b=b;
	}
	public void show()
	{
		showa();
		System.out.println("\n b="+b);
	}
}
class ChainConSuper
{
	public static void main(String []args)
	{
		B ob1 = new B();
		ob1.show();

		B ob2 = new B(100,200);
		ob2.show();
	}
}

//---------------------------------------------------------------------------------------------------------

	// Private Constructor

	A private constructor in Java is a constructor that is declared with the private access modifier. Unlike public 
	or protected constructors, it restricts object creation from outside the class. This means instances of the 	
	class cannot be created directly from outside the class.

	public class Example {
    		private Example() {
        		// Initialization code
    		}
	}


	Why Use a Private Constructor?
	Private constructors are used to achieve specific design patterns and behaviors in Java. 
	Some common use cases include:

	1. Singleton Design Pattern: A singleton ensures that only one instance of a class is created during the 
	   application's lifecycle. The class provides a global access point to this instance.

class Singleton {

    // Static variable to hold the single instance
    private static Singleton instance;
    private static String msg;

    // Private constructor to prevent instantiation
    private Singleton() {
        System.out.println("Singleton instance created.");
    }

    // Public method to provide access to the instance
    public static Singleton getInstance(String str) {
        if (instance == null) {
			msg=str;
            instance = new Singleton();
        }
        return instance;
    }

    public void displayMessage() {
        System.out.println("Hello from Singleton! "+msg);
    }
}
class DemoSingleton
{		
    public static void main(String[] args) {
        Singleton obj1 = Singleton.getInstance("One");  // Creates the instance
        Singleton obj2 = Singleton.getInstance("Two");  // Returns the same instance

        obj1.displayMessage();  // Output: Hello from Singleton!One
        obj2.displayMessage();  // Output: Hello from Singleton!One
        System.out.println(obj1 == obj2);  // Output: true (same instance)
    }
}

 //--------------------------------

	2. Factory Method Pattern: A factory method uses a private constructor to control the 
	   creation of objects and delegates object creation to static methods.

class Product {
    
	private String name;

    // Private constructor
    private Product(String name) {
        this.name = name;
    }

    // Static factory method
    public static Product createProduct(String type) {
        if (type.equalsIgnoreCase("Laptop")) {
            return new Product("Laptop");
        } else if (type.equalsIgnoreCase("Phone")) {
            return new Product("Phone");
        } else {
            return new Product("Unknown Product");
        }
    }

    public void display() {
        System.out.println("Product: " + name);
    }
}

class DemoFactoryMethodPattern
{
    public static void main(String[] args) {
        Product p1 = Product.createProduct("Laptop");
        Product p2 = Product.createProduct("Tablet");

        p1.display();  // Output: Product: Laptop
        p2.display();  // Output: Product: Unknown Product
    }
}

//-------------------------------------------------------------------------------

	3. Preventing Instantiation in Utility Classes:

	Utility classes contain static methods and constants. Since they don’t 
	need instances, a private constructor prevents instantiation.

class UtilityClass {

    // Private constructor to prevent instantiation
    private UtilityClass() {
        throw new UnsupportedOperationException("Cannot instantiate UtilityClass.");
    }

    // Static utility method
    public static int add(int a, int b) {
        return a + b;
    }
}
class DemoUtilityClasses
{
	
    public static void main(String[] args) {
        int result = UtilityClass.add(5, 10);
        System.out.println("Result: " + result);  // Output: Result: 15

        //  UtilityClass obj = new UtilityClass();  // Compilation error if uncommented
    }
}

//-------------------------------------------------------------------------------------------------------------------------------

	// Is Static Constructors Present in java? 

	No, the concept of "static constructors" does not exist in java. However, Java provides a way to 
	achieve similar functionality using static blocks. Static blocks are used to initialize static data 
	members of a class and are executed when the class is loaded.

	Static Blocks in Java
	Static blocks are used to initialize static fields and perform any necessary setup when the class is 
	loaded. They are executed only once, when the class is first loaded into memory.

	class <>
	{
		static {
    			// Initialization code
		}
	}

	As we need constructor in class to initilize the object, and it will be required for each object, means
	it must be at object level. as static meakes it class level it is not allowed in java.
	

//-----------------------------------------------------------------------------------------------------------


	// Default arguments in methods:  it is not allowed to write default arguments in java methods. Unlike some 
	   other programming languages (such as C++ or Python), Java does not support default arguments for methods. 
	   This means that when you define a method in Java, you must specify all the parameters explicitly, and 
	   the caller must provide values for all the parameters.

	Why Java Does Not Support Default Arguments?

	- Java aims to keep the language simple and readable. Default arguments can sometimes make the code harder 
	  to understand, especially when methods are overloaded or when the default values are not obvious.
	- Java emphasizes consistency in its syntax and semantics. Introducing default arguments could lead to 
	  inconsistencies and potential ambiguities in method overloading and method resolution.
	- Java has a strong emphasis on backward compatibility. Introducing default arguments could break existing 
	  code or introduce subtle bugs in legacy systems.

	Alternatives to Default Arguments: 

	While Java does not support default arguments, there are several alternatives to achieve similar functionality:

	1. Method Overloading: You can define multiple versions of a method with different parameter lists. This allows 
	you to provide default values by calling the appropriate overloaded method.

public class Example {
    public void display(String message) {
        System.out.println(message);
    }

    public void display() {
        display("Default message");
    }

    public static void main(String[] args) {
        Example example = new Example();
        example.display(); // Output: Default message
        example.display("Custom message"); // Output: Custom message
    }
}

//--------------

	2. Builder Pattern: The Builder pattern is a design pattern that allows you to construct complex objects 
	   step by step. It provides a flexible way to set default values and build objects with optional parameters.


class Product {
    private String name;
    private double price;
    private String category;

    private Product(Builder builder) {
        this.name = builder.name;
        this.price = builder.price;
        this.category = builder.category;
    }

    public static class Builder {
        private String name = "Default Name";
        private double price = 0.0;
        private String category = "Default Category";

        public Builder setName(String name) {
            this.name = name;
            return this;
        }

        public Builder setPrice(double price) {
            this.price = price;
            return this;
        }

        public Builder setCategory(String category) {
            this.category = category;
            return this;
        }

        public Product build() {
            return new Product(this);
        }
    }

    @Override
    public String toString() {
        return "Product [name=" + name + ", price=" + price + ", category=" + category + "]";
    }
}

public class MainBuilderPattern {
    public static void main(String[] args) {
        Product product1 = new Product.Builder().build();
        Product product2 = new Product.Builder().setName("Laptop").setPrice(999.99).build();

        System.out.println(product1);
        System.out.println(product2);
    }
}

//----------------------------
	3. Varargs: Varargs (variable-length arguments) allow you to pass a variable number of 
	   arguments to a method. This can be used to simulate default arguments by checking the 
	   length of the varargs array.

public class VarargsExample {
    public void display(String... messages) {
        if (messages.length == 0) {
            System.out.println("Default message");
        } else {
            for (String message : messages) {
                System.out.println(message);
            }
        }
    }

    public static void main(String[] args) {
        VarargsExample example = new VarargsExample();
        example.display(); // Output: Default message
        example.display("Custom message 1", "Custom message 2"); // Output: Custom message 1 Custom message 2
        example.display("One", "Two", "Three"); 
    }
}


//-----------------------------------------------------------------------------------------------------------

	// Is friend function allowed in Java like C++?

		No, the concept of "friend functions" as found in C++ does not exist in Java. Friend functions 
		in C++ allow a function to access the private and protected members of a class, even if the function 
		is not a member of that class. This is not possible in Java due to its strict access control and 
		encapsulation principles.

	Alternatives to Friend Functions in Java
	While Java does not support friend functions, there are several design patterns and techniques that can achieve 
	similar functionality:

	- Package-Private Access:
		By placing classes in the same package, you can allow them to access each other's package-private 
		(default) members. This provides a level of encapsulation while still allowing controlled access.

	- Nested Classes:
		Nested classes (inner classes) can access the private members of their enclosing class. This allows 
		for controlled access to private members.

	- Getter and Setter Methods:
		Provide public getter and setter methods to access and modify private fields. This is a common 
		practice in Java to control access to private members.
	
	- Interfaces:
		Define interfaces that provide access to specific methods or fields. This allows controlled access 
		to private members through the interface.


//-----------------------------------------------------------------------------------------------------------------

	Garbage Collector (GC): 

	 In Java, the Garbage Collector (GC) is a part of the Java Virtual Machine (JVM) responsible for 
	 managing memory. It automatically reclaims memory that is no longer in use, ensuring efficient memory 
	 utilization and preventing memory leaks.

	 In another words, It will release the derefernced locations, the derefernced locations are those allocated
	 locations, which are not refered by any reference variables.


			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][/][][][][][][][/][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][/][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]
			[][][][][][][][][][][][]


	Demo ref=new Demo();
	Demo dob=new Demo();
	

		ref
 		 [ ] ------------> [][][][][][][][][][][][]


		dob
 		 [ ] ------------> [][][][][][][][][][][][]



	ref=dob;

		ref		  Dereferenced Location
 		 [ ]		 [][][][][][][][][][][][]
		  |_________________
		 	           |
	      dob                  V
 		 [ ] ------------> [][][][][][][][][][][][]


 
	Garbage collector is a member which is used to free the dereferenced location. It will
	perform same task when it will get enough idle time of processor.

	If you want to utilize the resources hold by that object just before release of that location
	(done with the help of destructor in C++), the java provides the following method.

	protected void finalize()
	{
		--------------;
		-------------;
	}


	If you want to request early release then call System.gc();
import java.util.Scanner;
class Employee
{
	private String nm;
	private int eid;
	private double sal;

	Employee()
	{
		nm="";
		eid=-1;
		sal=-1.0;
	}	
	Employee(String nm,int eid,double sal)
	{
		this.nm=nm;
		this.eid=eid;
		this.sal=sal;
	}
	public void display()
	{
		System.out.println("Name: "+nm);
		System.out.println("Employee ID: "+eid);
		System.out.println("salary: "+sal);
	}
	protected void finalize()
	{
		System.out.println(" In finalize() method");
	}
}

class EmployeeMain
{ 
	public static void main(String []args) throws InterruptedException
	{
		{
			Employee eob=new Employee("Abhi",11,50000);
			eob.display();
			eob=null;
		}
		System.gc();
		Thread.sleep(5000);
		System.out.println(" End of program: ");
	}
}

	The Garbage Collector (GC) in programming, particularly in languages like Java, is a mechanism for automatic memory 
	management. Its primary purpose is to reclaim memory occupied by objects that are no longer in use by a program, 
	preventing memory leaks and ensuring efficient utilization of system memory.

	Key Points About Garbage Collection

	Automatic Memory Management:
	In languages like Java, developers do not manually allocate or deallocate memory for objects. The GC handles the cleanup 
	of unused objects, freeing the programmer from this responsibility.

	Managed Heap Memory:
	Objects in Java are created in the heap memory. The GC identifies objects that are no longer reachable and removes them 
	to free up space for new objects.

	Reachability:
	An object is considered unreachable if it is no longer accessible through any reference in the program. If no thread can 
	access an object, it becomes eligible for garbage collection.

	Garbage Collection Process:
	Mark: The GC identifies all objects currently in use or "reachable."
	Sweep: The GC removes objects that are no longer reachable, freeing up memory.
	Compact (optional): In some implementations, after sweeping, the memory is compacted to reduce fragmentation and 
	optimize performance.

	Generational Garbage Collection:
	Many modern GCs, including those in Java, use a generational model, dividing the heap into:
	Young Generation: Newly created objects. Most objects are short-lived and are quickly collected.
	Old Generation (Tenured): Objects that survive multiple GC cycles in the young generation are moved here.
	Permanent Generation (Metaspace): Stores metadata about classes and methods. (In Java 8 and later, this is replaced by 
	Metaspace.)

	Types of Garbage Collectors in Java:
	Serial Garbage Collector: A simple GC for single-threaded applications.
	Parallel Garbage Collector: Uses multiple threads for GC tasks, suited for multi-threaded environments.
	Concurrent Mark-Sweep (CMS) Collector: Reduces pause times by running GC concurrently with the application threads.
	G1 Garbage Collector: Aims to achieve predictable pause times and improved performance by dividing the heap into regions.
	ZGC: Designed for very low-latency applications, with extremely short pauses.
	Shenandoah GC: Another low-latency garbage collector.

	GC Triggers:
	The JVM triggers garbage collection when it detects that memory is running low or at certain points in the program 
	execution. It can also be triggered explicitly using the method:

	System.gc();

	However, calling this method does not guarantee immediate garbage collection; it's just a suggestion to the JVM.

	Advantages of Garbage Collection:
	Prevents memory leaks.
	Simplifies memory management for developers.
	Helps in managing complex object lifecycles automatically.

	Disadvantages of Garbage Collection:
	Performance Overhead: GC can cause pauses in program execution (known as "stop-the-world" events).
	Less control over memory management compared to manual memory management (e.g., in C/C++).

	//-----------------------------------------

	Generational Garbage Collection is a strategy used in modern garbage collection systems (including Java's JVM) to 
	optimize memory management. It is based on the observation that most objects have a short lifespan, while a smaller 
	number live longer. This strategy divides the heap memory into generations, where objects are grouped by their age, 
	to improve performance and minimize overhead.

	Generations in the Heap Memory
	The heap is divided into three main regions:

	Young Generation:
	This is where all newly created objects are allocated.
	It is further divided into:
	Eden Space: All new objects are initially allocated here.
	Survivor Spaces (S0 and S1): After the first garbage collection, objects that survive are moved here.
	Most objects in the Young Generation are short-lived and are quickly garbage collected. This process is called a Minor GC.
	
	Old Generation (Tenured Generation):
	Objects that survive multiple Minor GCs are promoted to the Old Generation.
	These objects tend to have a longer lifespan.
	Garbage collection in this space is called a Major GC or Full GC.
	Major GC is more time-consuming compared to Minor GC, as it operates on a larger memory space.

	Permanent Generation (or Metaspace):
	In older versions of Java (up to Java 7), the Permanent Generation was used to store metadata about classes, 
	methods, and other JVM structures.
	In Java 8 and later, this was replaced by Metaspace, which is not part of the heap and is allocated in native memory.

		+-------------------+-------------------+-------------------+
		|   Young Gen       |    Old Gen        |   (Metaspace)     |
		|                   |                   |                   |
		|   +-----------+   |                   |                   |
		|   |   Eden    |   |                   |                   |
		|   +-----------+   |                   |                   |
		|   | Survivor0 |   |                   |                   |
		|   +-----------+   |                   |                   |
		|   | Survivor1 |   |                   |                   |
		+-------------------+-------------------+-------------------+

//-----------------------------------------------------------------------------------------------------------------

	// Using the static keyword in java.


	// Static variable(static data member): In Java, a static data member (also known as a static variable) is a 				variable that is shared among all instances of a class. It is declared with the static keyword, meaning 
		that it belongs to the class itself rather than to any specific instance of the class. As a result,
		static data members have the same value across all instances of the class.

	 Characteristics of Static Data Members:

	- Shared Among Instances: All objects of the class share the same static variable, which means that if one 
	  object modifies the static variable, the change is reflected across all objects.

	- Class Level: A static variable is associated with the class rather than any instance of the class. 
	  It can be accessed directly using the class name without creating an object of the class.

	- Memory Allocation: Static variables are allocated memory only once, when the class is loaded into memory, 
	  and they retain their values throughout the execution of the program.


	// static method (static member function):

	A static member function (also known as a static method) in Java is a method that belongs to the class itself,
	rather than to instances (objects) of the class. It can be called on the class directly, without needing to 
	create an object of that class. Static methods are often used for utility or helper functions, where the method 
	does not need access to instance variables or methods.

	Characteristics of Static Member Functions:

	- Class-Level Function: A static method is associated with the class itself rather than with any specific 
	  object or instance of the class. This means that it can be called without creating an object.

	- Access to Static Members: Static methods can access other static members (variables and methods) of the class.
	  However, they cannot directly access instance variables or instance methods, because instance variables belong 
	  to specific objects, and static methods do not belong to any specific object.

	- Memory Allocation: Static methods are allocated memory once, when the class is loaded into memory, and they 
	  exist as long as the class exists in memory.

	- Cannot Use this: Since static methods do not belong to any particular object, they cannot use the this keyword. 
	  The this keyword refers to the current object, which does not exist for static methods.

		Memory allocated for all objects of class Item
	 ________________________________________________________________________
	 |common memory area							|
	 |	void setData(){}		tot				|
	 |	void showData(){}		 [ 0.0 ]			|
	 |	static void showTotalBill()					|
	 |______________________________________________________________________|
	 |Individual memory area						|
	 |	ob1		ob2		list				|
	 |	[]              []  		[    ] - For data only		|
	 |									|
	 |______________________________________________________________________|
	

	In above program, the variable tot holds the data i.e. total bill which is not secure, so we want to hide
	it within a class.


import java.util.Scanner;
class Item
{
	private int icode;
	private double iprice;
	private static double tot;
	public void setData()
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the code of item: ");
		icode=sc.nextInt();
		System.out.println("Enter the price of item: ");
		iprice=sc.nextDouble();
		tot = tot + iprice;
	}
	public void showData()
	{
		System.out.print("\n Item Code: "+icode+"\t Price: "+iprice);
	}
	public static void showTotalBill()
	{
		System.out.println("\n Total Bill: "+tot);
	}
}
class MainItemClass2
{
	public static void main(String []args)
	{
		Item.showTotalBill();
		Item []list = new Item[5];
		
		System.out.println("Enter the details of five Items: ");
		for(int i=0;i<5;i++)
		{
			list[i]=new Item();
			list[i].setData();
		}

		System.out.println("\n Item List ");
		for(int i=0;i<5;i++)
		{
			list[i].showData();
		}
		Item.showTotalBill();
	}
}

//-----------------------------------------------------------------------------------------------------------

	// In a different Style: Using the setter and getter methods


import java.util.Scanner;
class Product
{
	private int id;	
	private static int tot;
	private String name;
	private double price;
	
	public void setId(int id) {
		this.id=id;
	}
	public int getId() {
		return id;
	}
	
	public void setName(String name) {
		this.name=name;
	}
	public String getName() {
		return name;
	}
	
	public void setPrice(double price) {
		this.price = price;
		tot+=this.price;
	}
	public double getPrice() {
		return price;
	}

	public String toString() {
		return "Produce Details: ID: "+id+" Name: "+name+"\n Price: "+price;
	}

	public static float getTot() {
		return tot;
	}
}
class DemoProduct
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the prduct count: ");
		int cnt = sc.nextInt();
		Product []p1 = new Product[cnt];

		int i=0;
		int id;
		String name="";
		double price;

		while(true) {
			System.out.println("Enter 1 insert and the 2 to display product details 3 to display total Bill: ");
			int opt = sc.nextInt();

			if(opt==1) {
				 System.out.println("Enter the id, name and price: ");
				 p1[i]=new Product();
				 id=sc.nextInt();
				 p1[i].setId(id);

				 name=sc.nextLine();
				 name=sc.nextLine();
				 p1[i].setName(name);

				 price=sc.nextDouble();
				 p1[i].setPrice(price);

				 i++;
			}
			else if (opt==2) {
				System.out.println("\n ----------- List of Product ---------- ");
				for(int j=0; j<i ; j++)	{
					System.out.println(p1[j]);
				}
			
			}
			else if (opt==3) {
				System.out.println("\n ----------- Pay Bill: "+Product.getTot()+" ---------- ");

			}
		}
	}
}

	//-----------------------------

	// Static initializer (Static Block):

	In Java, a static initializer (also known as a static block) is a special code block that is used to initialize 
	static variables when the class is loaded into memory. It is executed only once when the class is first loaded, 
	and not every time an object of the class is created. This is different from instance initialization, which 
	occurs whenever a new instance of the class is created.

	- Declaration: A static block is declared using the static keyword, followed by a block of code enclosed in 
	  curly braces {}. It is placed inside the class, but outside any methods or constructors.

	  i.e.
		class Example
		{
			int x;
			static double y;
			static
			{
				y=100.0;
			}
			....
		}

	- It is used, To initialize static variables or perform any setup that is needed at the class level (before 
	  any objects are created).
	- Useful for complex initialization of static variables, especially if the initialization requires multiple 
	  lines of code or logic that cannot be done in a simple assignment.
	- If there are multiple static blocks in a class, they will execute in the order in which they appear 
	  in the code.
	- A static block can also handle exceptions. If an exception is thrown within a static block, it can be 
	  caught and handled, preventing the class from failing to load.


	// lets see the default values of static variables

class Example
{
	static int x;		// we not decl. as private,it is default, and accessible using 
	static double y;	// .operator directly. And we want to access directly for checking purpose.
	static boolean z;
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}


	// class with static initilizer

class Example
{
	static int x;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		x=5;
		y=x*x/3.0;
		System.out.println("\n In Static Block");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}


	// A class with multiple static Blocks
class Example
{
	static int x;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		System.out.println("\n In Static Block-1");
	}	
	static
	{
		x=5;
		System.out.println("\n In Static Block-2");
	}	
	static
	{
		y=x*x/3.0;
		System.out.println("\n In Static Block-3");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}


	// static block with try-catch (handling exception in static block)

class Example
{
	static int x;
	static int t;		// we not decl. as private coz want to access directly
	static double y;	// for checking purpose
	static boolean z;
	static
	{
		z=true;
		t=2;  // try with t=0
		System.out.println("\n In Static Block-1");
	}	
	static
	{
		try
		{
			x=23/t;
		}
		catch (Exception e)
		{
			System.out.println("\n Unable to init x, so init to default value");
		}
		System.out.println("\n In Static Block-2");
	}	
	static
	{
		y=x*5.7/x;
		System.out.println("\n In Static Block-3");
	}
	// ... some another members
}
class DemoStatic 
{
	public static void main(String[] args) 
	{
		System.out.println("value of x: "+Example.x);
		System.out.println("value of y: "+Example.y);
		System.out.println("value of z: "+Example.z);
	}
}

//---------------

	// Using static nested class

	In Java, a static class typically refers to a nested static class. It is a class defined within another class 
	but declared with the static keyword. Static classes are a way to define inner classes that don't depend on an
	instance of the outer class, which allows them to behave differently from regular inner classes.

	Key Points About Static Classes
	- It must be in a scope of enclosing class(Outer), Must not be decl. within constructor or method of outer class.
	- A static class in Java is always a static nested class, which is a class that is defined within another class, 
	  but with the static keyword. It is an inner class but without a reference to an instance of the outer class.
	- A static nested class does not have access to the instance variables or instance methods of the outer class. 
	  It can only directly access the static members of the outer class.
	- Unlike regular inner classes, which require an instance of the outer class to be created, a static nested 
	  class can be instantiated independently, without needing an instance of the enclosing (outer) class.
	- wheneven you want to use inner class, It must be written in fully qualified manner, while creating object 
	  and allocating memory for it.

class Outer
{
	private int x;
	static class Inner
	{
		private int y;
		public void setData()
		{
			y=200;
		}
		public void showData()
		{
			System.out.println("y="+y);
		}
	}
	public void in()
	{
		x=100;
	}
	public void out()
	{
		System.out.println("x="+x);
	}
}
class DemoStaticInnerClass 
{
	public static void main(String[] args) 
	{
		Outer ob1=new Outer();
		ob1.in();
		ob1.out();

		Outer.Inner ob2 = new Outer.Inner();
		ob2.setData();
		ob2.showData();
	}
}


	// Accessing static member of Inner and Outer class

class Outer
{
	static int var_out;
	private int x;
	static class Inner
	{
		static int var_in;
		private int y;
		public void setData()
		{
			y=200;
		}
		public void showData()
		{
			System.out.println("y="+y);
			System.out.println("var_out="+var_out); // Inner method able to access static members of outer class
		}
	}
	public void in()
	{
		x=100;
	}
	public void out()
	{
		System.out.println("x="+x);
		// System.out.println("var_in="+var_in); // Error: we cant access the static member of inner class from outer method
	}
}
class DemoStaticInnerClass 
{
	public static void main(String[] args) 
	{
		Outer ob1=new Outer();
		ob1.in();
		ob1.out();

		Outer.Inner ob2 = new Outer.Inner();
		ob2.setData();
		ob2.showData();
	}
}

	Static nested classes are often used when you want to logically group a class inside another class, but it 
	does not need access to the outer class instance.

//---------------

	// Using Static import
	
	In Java, static import is a feature that allows you to access static members (fields and methods) of a 
	class without needing to qualify them with the class name. This can make the code more concise and 
	readable, especially when you use multiple static members from a class frequently. 
	Static import is introduced in Java 5 (with the release of J2SE 5.0).

	syntax:
	 - 1. Importing Specific Static Members: import static packageName.ClassName.staticMember;
	 - 2. Importing All Static Members: import static packageName.ClassName.*;


// we have to write program to calculate the area of circle(pi*r*r)
/*
// in simple way
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=3.142*r*r;
		System.out.println("Area of Circle: "+area);
	}
}

//----------------------------

// Using java.lang.Math class

class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=Math.PI*Math.pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}


//----------------------------

// Using static import(pow() only)

import static java.lang.Math.pow;
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=Math.PI*pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}

*/
//----------------------------

// Using static import-Importing all static members
import static java.lang.Math.*;
class ExampleStaticImport
{
	public static void main(String[] args) 
	{
		double r=4;
		double area=PI*pow(r,2);
		System.out.println("Area of Circle: "+area);
	}
}


	In above examples:

	- Without static import: You need to fully qualify Math.pow(2, 3).
	- With static import: You can simply use pow(2, 3) directly, making the code cleaner.

	Drawbacks of Static Import:

	- Ambiguity: Static import can lead to ambiguity when multiple static members with the same name are 
	  imported from different classes.
	- Reduced Clarity: it become difficult to determine which static members belong to which class in case 
	  multiple static imports.

//----------------------------------------------------------------------------------------------------------------------
//----------------------------------------------------------------------------------------------------------------------

	// Inner(Nested) classes in Java: 

	In Java, an inner class is a class defined within another class. Inner classes are primarily used to logically 
	group classes that will only be used in one place, increasing encapsulation and improving code readability.

	Types of Inner Classes in Java:
	- Nested Inner Class (Non-static Inner Class)
	- Static Nested Class
	- Method-Local Inner Class
	- Anonymous Inner Class

	// Nested Inner Class (Non-static Inner Class):  A non-static inner class is associated with an instance 
	   of the outer class and can access its members (including private members).
	
class Outer 
{
	private int x=100;
	private static int y=100;
	void show()
	{
		System.out.println("Inside Outer Class");
	}
    	class Inner 
	{
        	void display() 
		{
			show();
            		System.out.println("Inside Non-static Inner Class");
            		System.out.println("x= "+x);
            		System.out.println("y= "+y);
        	}
   	}
}
class DemoInner
{
	public static void main(String []args)
	{
		Outer out = new Outer();
		out.show();

		Outer.Inner in = out.new Inner();
		in.display();
	}
}
	// Note
	- If you want to create the object of inner class, first you need to create the object of outer class.
	  and using instance(object) of outer class, we need to use inner class.
	- Inner class having access to outer class member(methods and variables) directly, but 
	  vice-versa not possible.

//-----------------

	// - Static Nested Class: A static nested class is associated with the outer class itself rather than an 
	     instance. It cannot directly access instance variables or methods of the outer class.

class Outer 
{
	private static int y=100;
    	static class Inner 
	{
        	void display() 
		{
            		System.out.println("Inside Non-static Inner Class");
            		System.out.println("y= "+y);
        	}
    	}
}
class DemoInner
{
	public static void main(String []args)
	{
		Outer.Inner in = new Outer.Inner();
		in.display();
	}
}

	// Note
	- If you want to create the object of static inner class, you don't need object of outer class.
	  only outer class name is sufficient to access inner static-nested class.
	- Static inner class having access to only static members of outer class.
	- Non-static methods and instance variables of outer class can not be accessed directly.

//----------------

	// - Method-Local Inner Class: A method-local inner class is defined within a method and is only 
	     accessible within that method.

class Outer 
{
	void outerMethod() 
	{
        	class MethodInner 
		{
            		void display() 
			{
                		System.out.println("Inside Method-Local Inner Class");
            		}
        	}
        	MethodInner inner = new MethodInner();
        	inner.display();
    	}
	void anotherMethod()
	{
		MethodInner ob = new MethodInner(); // will generate error, coz member decl. 
	}					    // in a scope can be accessible with in only.
}

//----------------------

	// anonymous inner class: An anonymous inner class is a class without a name, typically 
				  used to override methods of an interface or superclass.


class Sample
{
	public void sayHi() {
		System.out.println("Hi From Sample");
	}
	public void sayHello() {
		System.out.println("Hello From Sample");
	}
	
}

class Test extends Sample {

	public void sayHello() {
		System.out.println("Hello From Test");
	}
}

class MainClassAIC
{
	public static void main(String []args) {

		Sample ob1 = new Sample();
		ob1.sayHi();
		ob1.sayHello();

		System.out.println("\n ---------------------------");

		Test ob2 = new Test();
		ob2.sayHi();
		ob2.sayHello();

		System.out.println("\n ---------------------------");

		Sample ob3 = new Sample() {
			int z=100;
			public void sayHello() {
				System.out.println("Hello From No-Name");
			}
		};
		ob3.sayHi();
		ob3.sayHello();
	}
}

//--------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------

	
	 // Using this keyword: 

		In Java, the this keyword is a reference to the current object within a class. It is 
		commonly used in methods, constructors, and inner classes to distinguish between instance 
		variables and parameters or to call other constructors or methods within the same class.

		Here are some common uses

	 1. Returning the Current Object: 'this' always refers to invoking object(object
	    on which method is called). Some times we need to return it from method defined within same class
	    in that case 'this' used as shown below..!!


import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public void setData()
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter the Name: ");
		name = sc.nextLine();

		System.out.println("Enter the ID: ");
		id = sc.nextInt();

		System.out.println("Enter the Age: ");
		age = sc.nextInt();

		System.out.println("Enter the Salary: ");
		salary = sc.nextDouble();
	}
	public void showData()
	{
		System.out.print("\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
	public Person findElder(Person x)
	{
		if(x.age>age)
			return x;
		else 
			return this;
	}
}
class ThisExample 
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();
		p1.setData();

		Person p2 = new Person();
		p2.setData();

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();

		Person t = p1.findElder(p2);		
		System.out.println("\n Elder Person ");
		t.showData();
	}
}

//--------------------------------

	 2. Referring to Instance Variables: When method or constructor parameters have the same name as instance 
	 variables, this helps differentiate between the two.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		id = -1;
		name = "NA";
		this.age = -1;
		this.salary = -1.0;
	}
	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	public void setData()
	{
		Scanner sc = new Scanner(System.in);

		System.out.println("\n Enter the Name: ");
		name = sc.nextLine();

		System.out.println("Enter the ID: ");
		id = sc.nextInt();

		System.out.println("Enter the Age: ");
		age = sc.nextInt();

		System.out.println("Enter the Salary: ");
		salary = sc.nextDouble();
	}
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();
		p1.showData();

		p1.setData();

		Person p2 = new Person();
		p2.setData(11,"Abhay",23,12.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
	}
}

//-----------------------------------

	3. Calling Another Constructor (Constructor Chaining): The this keyword can be used to call 
	   another constructor within the same class.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); // constructor chaining
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); // constructor chaining
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}

//-----------------------------------

	4. Calling Current Class Methods: this can be used to explicitly call methods of the current object.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); // constructor chaining
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); // constructor chaining
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
		System.out.print(" - Status: "+this.isWorking(this.salary));
	}
	private String isWorking(double sal)
	{
		if(sal>0)
			return "Working";
		else
			return "Not Working";
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}

//-----------------------------------------------------------------------------------------------------------------

	// 5. Passing the Current Object as a Parameter: The this keyword can be passed as an argument to 
	      methods or constructors.

import java.util.Scanner;
class Person
{
	private int id;
	private String name;
	private int age;
	private double salary;
	public Person()
	{
		this(-1,"NA",-1,-1.0); 
	}
	public Person(int id, String name)
	{
		this(id,name,-1,-1.0); 
	}

	public Person(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}
	
	public void setData(int id, String name, int age, double salary)
	{
		this.id = id;
		this.name = name;
		this.age = age;
		this.salary = salary;
	}

	public void showData()
	{
		if(isWorking(this)) // display if working
			System.out.print("\n\n ID: "+id+"\t Name: "+name+"\t Age: "+age+"\t Salary: "+salary);
	}
	private boolean isWorking(Person p)
	{
		if(p.salary>0)
			return true;
		else
			return false;
	}
}
class ThisExample
{
	public static void main(String[] args) 
	{
		Person p1 = new Person();

		Person p2 = new Person(11,"Abhay");

		Person p3 = new Person();
		p3.setData(131,"Anand",43,52.34);

		System.out.println("\n Person List");
		p1.showData();
		p2.showData();
		p3.showData();
	}
}


//=====================================================================================================================

	
		// Forming the Class Relationship -  Inheritance and Association


		    Inheritance 				   Association

			IS-A					      HAS-A	

			person				  Engine		Music Player		
			  |				    |			   |		 
		---------------------			    |______________________|	
		|	 |	    |			Strong bonding 	|  weak bonding
	    Trainer   Student    Driver			 Composion     Car  Agrigation

				  		 
				CPP Code just for example

	class person						class Engine
	{							{
	};							};
	class Trainer : public person				class MusicPlayer
	{							{
	};							};
	class Student : public person				class Car
	{							{
	};								Engine ob1;
	class Driver: public person					MusicPlayer ob2;
	{							};
	};

                     | |					  | |
		      V					     	   V
  		Inheritance				 	Association




	- Inheritance: Inheritance is a mechanism where one class (called the child class or subclass) derives 
	  properties and behavior (fields and methods) from another class (called the parent class or superclass). 
	  It promotes code reusability and establishes a relationship like "is-a."

	-  Association: Association is a relationship between two classes that establishes a connection.

	Types of Association:
	 - Aggregation: A weak association where one object can exist independently of the other.
	 - Composition: A strong association where one object cannot exist independently of the other.

	// Inheritance

            /// Inheritance: It is act of defining the new class using the pre-defined classes.
                             It will provide the the next level of reusability.

    consider the example, in normal case,

    class employee              class student           class Teacher           class Driver
    {                           {                       {                       {
        char name[50];              char name[50];         char name[50];           char name[50];
        int age;                    int age;                int age;                int age;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
        -----------;                -----------;            -----------;            -----------;
    };                          };                      };                      };



    some elements are there in each class, and every class having code related to IO of those
    member, which is code repetition and can be avoided using the class inheritance as


    /// syntax of inheritance

    class <base/super/parent_class>
    {
        ........;
    };
    class <derived/sub/child_class> extends <base_class_nm>
    {
        --------;
        --------;
    };

        e.g.

        class person
        {
            char name[50];
            int age;
            --------------;
            --------------;
            --------------;
        };


class employee extends person  class student extends person  class Teacher extends person  class Driver extends person
{                               {                            {                              {
    -----------;                      -----------;                   -----------;                 -----------;
    -----------;                      -----------;                   -----------;                  -----------;
    -----------;                      -----------;                   -----------;                  -----------;
};                              };                            };                           };


///--------------------------------------------------------------------------------------------

///--------------------------------------------------------------------------------------------

        /// Types of Inheritance: In C++ we have seen following inheritances


            single          Multi-level          hierarchical        Multiple         Hybrid
          Inheritance       Inheritance           Inheritance       Inheritance     Inheritance

             [   ] A            [     ]  A             [ ] A           A       B       [ ]A                  A
               |                   |                    |              [ ]     [ ]      |                   [ ]
               |                [     ]  B        --------------        |_______|      [ ] B                 |
               V                   |              |            |             |          |         D     -------------
             [   ]  B           [     ]  C       [ ]B         [ ]c          [ ]        [ ] C     [ ]    |           |
                                                  |            |             C          |         |    [ ] B       [ ] C
                                              ---------      ---------                 [ ] -------|     |___________|
                                              |        |     |   |    |                 Z                     |
                                             [ ]      [ ]   [ ] [ ]  [ ]                                     [ ]
                                              D        E     F   G    H                                       D

    - single Inheritance:   One to one relationship, two layers
    - Multi-level Inheritance: one to one relationship, more than two layers
    - hierarchical Inheritance: One to many relationship
    - Multiple Inheritance: many to one relationship
    - Hybrid Inheritance: combinations of any two or more inheritance

	In Java, There are only three inheritances i.e. 

	- single Inheritance
	- multilevel Inheritance 
	- hierarchical Inheritance.

	*Note: multiple and Hybrid inheritancs are not present in java.
	

	- Single inheritance: 
	  Single inheritance in Java is a concept where a class inherits from one and only one parent (or superclass). 
	  It allows a child class to acquire the properties and methods of a single parent class, promoting code
	  reusability and a hierarchical relationship.

// Parent class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Child class
class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

// Child class
class Human extends Animal {
    void speak() {
        System.out.println("The human speaks.");
    }
}

// Main class
public class MainSingleInh {
    public static void main(String[] args) {
        Dog dob = new Dog();
        dob.eat(); // Inherited from the Animal class
        dob.bark(); // Defined in the Dog class

        Human hob = new Human();
        hob.eat(); // Inherited from the Animal class
        hob.speak(); // Defined in the Dog class
    }
}

//------------------------------


	// Accessing members of base class with different visibility.

class Base
{
	private int x=11;
	protected int y=22;
	int z=33; // default visibility
	public int t=44;
	// and some methods
}
class Derived extends Base
{
	public void display()
	{
		// System.out.println("\n x="+x);
		System.out.println("\n y="+y);
		System.out.println("\n z="+z);
		System.out.println("\n t="+t);
	}
}

class MainAccessSingle
{
	public static void main(String []args)
	{
		Derived ob = new Derived();
		ob.display();

		// System.out.println("\n x="+ob.x);
		System.out.println("\n y="+ob.y);
		System.out.println("\n z="+ob.z);
		System.out.println("\n t="+ob.t);
	}
}


------------ On Compile ----------------
MainAccessSingle.java:13: error: x has private access in Base
                System.out.println("\n x="+x);
                                           ^
1 error
Press any key to continue . . .

 -> which means that only private members are not inheritable.

 // After commenting above and accessing using . opertator

MainAccessSingle.java:27: error: x has private access in Base
                System.out.println("\n x="+ob.x);
                                             ^
1 error
Press any key to continue . . .

 -> which means that only private member not inheritable using . operator directly.

	// Note:
		- The extends keyword is used to establish the inheritance relationship.
		- The child class can access all non-private members (fields and methods) of the parent class.


//----------------------------------------------

	// Overloading and Overriding in the single inheritance.

	- Overloading:
	  Overloading occurs when two or more methods in the same class (or in a child class) have the same 
	  name but different parameter lists (number, type, or order of parameters). It is an example of 
	  compile-time polymorphism.

	- Key Points of Overloading:
		- Happens within the same class.
		- Methods must have the same name but different parameter lists.
		- Return type may or may not be different.
		- Resolved at compile time.


class Calculator {
    // Method 1: Adding two numbers
    int add(int a, int b) {
        return a + b;
    }

    // Method 2: Adding three numbers (overloading)
    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class MainOverloading {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(5, 10)); // Calls the first add method
        System.out.println(calc.add(5, 10, 15)); // Calls the second add method
    }
}


//---------------------------------------------------------

	- Overriding:

	  Overriding occurs when a child class provides its own implementation of a method that is already 
	  defined in the parent class. It is an example of runtime polymorphism.

	- Key Points of Overriding:
		 - Happens between parent and child classes.
		 - Method signature (name, parameters, and return type) must be exactly the same.
		 - Resolved at runtime (dynamic method dispatch).
		 - The access modifier of the overriding method must be the same or more permissive 
		   than the method in the parent class.

class Animal {
    void sound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    // Overriding the sound method of the parent class
    void sound() {
        System.out.println("The dog barks.");
    }
}

public class MainOverriding {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        myAnimal.sound(); // Calls the parent class method

        Dog myDog = new Dog();
        myDog.sound(); // Calls the overridden method in the child class
    }
}


	// Accessing the Overriden methods 

	In Java, when a method is overridden, the subclass version is called by default. However, if you want to 
	access the overridden method from the parent class in the subclass, you can use the super keyword. 
	This is useful when you want to extend the behavior of the parent class's method rather than 
	completely replacing

class Animal {
    void sound() {
        System.out.println("Some generic animal sound.");
    }
}

class Dog extends Animal {
    // Overriding the sound method of the parent class
    void sound() {
		super.sound();
        System.out.println("The dog barks.");
    }
}

public class MainOverriding {
    public static void main(String[] args) {

        Animal myAnimal = new Animal();
        myAnimal.sound(); // Calls the parent class method

	System.out.println("\n ---------------------- ");

        Dog myDog = new Dog();
        myDog.sound(); // Calls the overridden method in the child class
    }
}

//------------------------------------------------------------------------------------------

	// Defining the constructors in inheritance

	In Java, When we write the constructors in base and child class, 
	- if we create the base class object, only base class constructor will be executed.
	- if we create an object of child class, then first base class constructor and then child
	  class constructor will be executed. again it confirms that memory is allocated for both 
	  child and base classes.
	- Bydefault default constructors of both classes are executed.
	- If we invoke the parameterized constructor of child class, then at start it will invoke the 
	  default constructor of base class and then parameterized constructor of child.

	So we need to use super keyword to invoke the parameterized constructor of base class.


package com.archer.inhex;
class Person {

	//	fields
	private int uid;
	private String name;

	//	Constructors
	public Person() {
		uid = 0;
		name = "No Name";
	}

	public Person(int uid, String name) {
		super();
		this.uid = uid;
		this.name = name;
	}
	
	// setter and getter methods
	public int getUid() {
		return uid;
	}
	public void setUid(int uid) {
		this.uid = uid;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
}

class Student extends Person {
	// fields
	private int rno;
	private double per;
	
	// Constructors
	public Student() {
		rno = 0;
		per = 0.0;
	}
	
	public Student(int uid, String name, int rno, double per) {
		super(uid, name); // calls the para. constructor of base(super) class
		this.rno = rno;
		this.per = per;
	}
	
	public Student(int rno, double per) {
		this.rno = rno;
		this.per = per;
	}

	// setter and getter methods
	public int getRno() {
		return rno;
	}
	public void setRno(int rno) {
		this.rno = rno;
	}
	public double getPer() {
		return per;
	}
	public void setPer(double per) {
		this.per = per;
	}
}
public class MainClassSingleInh {

	public static void main(String[] args) {
		
		// Creating Object Using Setter and Getter methods
		Student s1 = new Student();
		s1.setName("Amol");
		s1.setUid(12345);
		s1.setRno(12);
		s1.setPer(78.45);
		System.out.println("Name: "+s1.getName()+"\t UID: "+s1.getUid()+"\t RNO: "+s1.getRno()+"\t Marks: "+s1.getPer()+"%");

		System.out.println("\n -------------------------------------------- ");
		
		// Creating the Object using the default Constructor
		Student s2 = new Student();
		System.out.println("Name: "+s2.getName()+"\t UID: "+s2.getUid()+"\t RNO: "+s2.getRno()+"\t Marks: "+s2.getPer()+"%");

		System.out.println("\n -------------------------------------------- ");
				
		// Creating the Object using the default Constructor
		Student s3 = new Student(15, 98.23); 
		// here the parameterized constructor of child class Student is invoked, and automatically it will invoke the default constructor of base class.
		System.out.println("Name: "+s3.getName()+"\t UID: "+s3.getUid()+"\t RNO: "+s3.getRno()+"\t Marks: "+s3.getPer()+"%");
		
		System.out.println("\n -------------------------------------------- ");
		
		// to invoke the base class we need to pass the arguments first.
		Student s4 = new Student(495867,"Uday",15,98.23); 
		System.out.println("Name: "+s4.getName()+"\t UID: "+s4.getUid()+"\t RNO: "+s4.getRno()+"\t Marks: "+s4.getPer()+"%");
		
	}

}

//------------------------------------------------------------------------------------------------------------
	// Using the 'super' Keyword

	The super keyword in Java is a powerful tool used within a subclass to directly refer to its immediate parent 
	class. It is primarily used to access parent class members (constructors, methods, or fields) that are overridden 
	or hidden by the subclass. 

	1. Using super to Call Overriden Parent Class Methods in child class.
	   When a subclass overrides a method from the parent class, the super keyword can be used to call the original 
	   method from the parent class. This is particularly useful when you want to reuse the parent class's logic 
	   while extending or modifying its behavior in the subclass.

	2. Using super to Access Overriden Parent Class Fields in child class.
	   If a subclass declares a field with the same name as a field in the parent class, the subclass's field hides 
	   the parent class's field. You can use super to access the hidden field in the parent class.

class Parent {
    String name = "Parent";
}

class Child extends Parent {
    String name = "Child";

    void printNames() {
        System.out.println("Name in Child: " + name);
        System.out.println("Name in Parent: " + super.name);
    }
}

public class MainSuper {
    public static void main(String[] args) {
        Child child = new Child();
        child.printNames();
    }
}


	3. Using super to Call Parent Class Constructors
	   You can use super() to call the parent class's constructor. This is often done to initialize the parent 
	   class fields with parameters passed via child class constructor.


	Rules and Notes:
	 - First Statement in Constructor: When used in a constructor, super() must be the first statement.
	   If you don't explicitly call super(), Java inserts a default super() call (to the no-argument constructor 
	   of the parent).

	- Only Immediate Parent: super always refers to the immediate parent class. It cannot access methods, fields, 
	  or constructors of ancestors beyond the immediate parent.

	- Access Modifiers:super respects Java's access control rules (e.g., private members of the parent class cannot 
	  be accessed using super).

	- No super in Static Contexts:super cannot be used in static methods or blocks because it depends on an instance.

//--------------------

	Are the constructors inheritable?

	No, constructors are not inheritable in Java. This is because constructors are not part of an object's
	instance or class; instead, they are special methods used for initializing an object when it is created. 
	Each class in Java must define its own constructors, even if it is a subclass.

	Can we override the constructor?

	No, constructors cannot be overridden in Java. This is because constructors are not inherited by subclasses, 
	which is a prerequisite for overriding a method. However, constructors can be overloaded within the same class.

//-----------------------------------------------------------------------------------------------------------------------

	// Using Final Keyword:

	In Java, the final keyword is a modifier that can be applied to variables, methods, and classes. 
	It serves different purposes depending on where it is used.


	1. Final Variables: A variable declared as final cannot have its value reassigned after it has 
			    been initialized. It makes the variable constant.

	Rules for Final Variables:

	- If the variable is a primitive type, its value cannot be changed after initialization.
	- If the variable is a reference type (like an object or array), the reference cannot be 
	  changed, but the object's state(like values of fields) can be modified.


	public class FinalVariableExample {
    		final int CONSTANT = 100;  // Initialized during declaration
    		final int anotherConstant;
    
		FinalVariableExample() {
        		anotherConstant = 200;  // Initialized in the constructor
    	}

    public static void main(String[] args) {
       
	FinalVariableExample example = new FinalVariableExample();
        System.out.println(example.CONSTANT);
        System.out.println(example.anotherConstant);

        // example.CONSTANT = 300; // Error: Cannot assign a value to a final variable
		// example.anotherConstant = 400; // Error: Cannot assign a value to a final variable
    }
}

	Note: 
	     - Once you initilize, Value of final variable can not be altered, Even using constructor, 
	       when it is assigned already.
	     - Constructor allows to initilize, only when it is not assined in decleration.

//---------------------------

class Demo
{
	private int x;
	public Demo() {
		x=10;
	}
	public Demo(int t) {
		x=t;
	}
	public void setx() {
		x=1000;
	}
	public void show() {
		System.out.println("x="+x);
	}
}
class FinalVariableExample1 
{
	public static void main(String[] args) 
	{
		final Demo ob1 = new Demo(100);
		Demo ob2 = new Demo(200);
		
		ob1.show();
		ob2.show();

		//ob1=ob2;	// error: cannot assign a value to final variable ob1
		// the reference cannot be changed coz ob1 is final

		ob1.setx(); // evenif ob1 is final as we are not chamging the reference, it will allow
			    // to change the values of fields.
		ob1.show();
	}
}

---------------------

	2. Final Methods: A method declared as final cannot be overridden by subclasses. This is useful 
			when you want to prevent a specific behavior from being modified in child classes.


class Base {
	final public void message() {
		System.out.println("In the Base Class");
	}
}
class Child extends Base {
	public void message() { // error: message() in Child cannot override message() in Base overridden method is final
		System.out.println("In the Child Class");
	}
}
class FinalMethodExample
{
	public static void main(String[] args) 
	{
		Child ob = new Child();
		ob.message();
	}
}

//------------------------------------------

	3. Final Classes: A class declared as final cannot be extended. This is useful for creating immutable 
			  classes or when you want to prevent inheritance.

final class FinalClass {
    void display() {
        System.out.println("This is a final class.");
    }
}

// class SubClass extends FinalClass { 
//     // Error: Cannot inherit from final class
// }

public class FinalClassExample {
    public static void main(String[] args) {
        FinalClass obj = new FinalClass();
        obj.display();
    }
}

//----------------------------------------


4. Final Parameters:
When a parameter is declared as final in a method, it means that 
the value of the parameter cannot be changed within the method.


class Demo
{
	private int x;
	public void in(final int t)
	{
		t=78; // error: final parameter t may not be assigned
		x=t;
	}
	public void show()
	{
		System.out.println("\n x="+x);
	}
}
class DemoFinalParameter
{
	public static void main(String []args)
	{
		Demo ob=new Demo();
		ob.in(100);
		ob.show();
	}
}

Output (Error on Compie)

DemoFinalParameter.java:114: error: final parameter t may not be assigned
                t=78;
                ^
1 error
Press any key to continue . . .

//------------------------------------------

	// Passing the mutable and immutable objects 

	- When we pass the refence of an object which is mutable. then it will allows to modify the contents
	  of actual location, it will keep doing same, even if the are decl. as final while collecting as a
	  a formal arguments, coz in that case reference modification will not attempted.

	- Even though the reference is fixed, the object's internal state (its fields or elements) can still be 
	  modified, provided the object itself is mutable (not declared final for fields or does not contain 
	  immutable fields).

	- When we pass the refence of an object which is immutable, and you try to change the original locations,
	  then as the original location is immutable, the newly assigned data stored in the memory and the formal
	  arguments start refering to that new location.(Implicitly reference modification is attempted) 

	- To avoid such reference modification in case of immutable object the final keyword is used.

	- The object's state, such as fields or array elements, can still be modified as long as the object is mutable.

class DemoRefPass 
{
	public static void fun(String s3, String s4)
	{
		s3="good day";
		s4="bye bye";
	}
	public static void main(String[] args) 
	{
		String s1="Hi";
		String s2="Hello";
		System.out.println("Before Call: s1 - "+s1+"\t s2 - "+s2);
		fun(s1,s2);
		System.out.println("After Call: s1 - "+s1+"\t s2 - "+s2);
	}
}

 It will gives like output same as that of(or like) "By Value", due to String Object is immutable.

	// To avoid it, use final

class DemoRefPassImmutable
{
	public static void fun(final String s3, final String s4)
	{
		s3="good day";
		s4="bye bye";
	}
	public static void main(String[] args) 
	{
		String s1="Hi";
		String s2="Hello";
		System.out.println("Before Call: s1 - "+s1+"\t s2 - "+s2);
		fun(s1,s2);
		System.out.println("After Call: s1 - "+s1+"\t s2 - "+s2);
	}
}

 //------- on compile ----------

DemoRefPassImmutable.java:5: error: final parameter s3 may not be assigned
                s3="good day";
                ^
DemoRefPassImmutable.java:6: error: final parameter s4 may not be assigned
                s4="bye bye";
                ^
2 errors
Press any key to continue . . .

//-----------------------------------------

	// Passing mutable object

class Num
{
	private int x;
	public void setX( int x) {
		this.x = x;
	}
	public int getX() {
		return x;
	}
}
class DemoRefPassMutable
{
	public static void fun(final Num ob3, final Num ob4)  // absence of final will gives same output
	{
		ob3.setX(1000);
		ob4.setX(2000);
	}
	public static void main(String[] args) 
	{
		Num ob1 = new Num();
		Num ob2 = new Num();
		ob1.setX(10);
		ob2.setX(20);
		System.out.println("Before Call: ob1 - "+ob1.getX()+"\t ob2 - "+ob2.getX());
		fun(ob1,ob2);
		System.out.println("Before Call: ob1 - "+ob1.getX()+"\t ob2 - "+ob2.getX());
	}
}


//-------------------------

	// Note to Remember

	- Private members are not inheritable.

class Sample
{
	private int x;
	public float y;
	double z;
	protected char ch;
}
class Test extends Sample
{
	public Test()
	{
		x=100; // error: x has private access in Sample
		y=3.4F;
		z=45.23;
		ch='w';
	}
}
class DemoTestAccess
{
	public static void main(String[] args) 
	{
		Test ob = new Test();
	}
}


//---------------------------------------------------------------------------------------------------------------------


- Multilevel Inheritance:

		[ ] Person		in() and out()	
		 |				 
		 |				 
	  	[ ] Student		input() and output()
		 |
		 |
		[ ] Sport		set() and show()

import java.util.Scanner;
class Person
{
	private String nm="";
	private int age;
	public void in()
	{
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the name of person: ");
		nm=sc.nextLine();

		System.out.println("\n Enter the age of person: ");
		age=sc.nextInt();
	}
	public void out()
	{
		System.out.println("\n Name: "+nm+"\t age: "+age);
	}
}
class Student extends Person
{
	private int rno;
	private double per;
	protected void input()
	{
		//in();
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the rno of Student: ");
		rno=sc.nextInt();

		System.out.println("\n Enter the percentage of Student: ");
		per=sc.nextDouble();
	}
	public void output()
	{
		//out();
		System.out.println("\n RNO: "+rno+"\t Percentage: "+per);
	}
}
class Sport extends Student
{
	private int points;
	void set()
	{
		//in();
		//input();
		Scanner sc=new Scanner(System.in);
		System.out.println("\n Enter the grade points of Student: ");
		points=sc.nextInt();
	}
	public void show()
	{
		out();
		output();
		System.out.println("\n Points: "+points);
	}
}
class MainStudentMultilevel
{
	public static void main(String []args)
	{
		Sport s=new Sport();

		s.in();
		s.input();
		s.set();

		s.show();	
	}
}

//-------------------------------------------------------------------------------------------------

	/// Using the constructors in inheritance

class Base
{
	private int a;
	public Base()
	{
		System.out.println("\n In Base default");
		a=10;
	}
	public Base(int x)
	{
		System.out.println("\n In Base para");
		a=x;
	}
	public void showBase()
	{
		System.out.println("\n a="+a);
	}
}
class ImdBase extends Base
{
	private int b;
	public ImdBase()
	{
		System.out.println("\n In ImdBase default");
		b=20;
	}
	public ImdBase(int x, int y)
	{
		super(x);
		System.out.println("\n In ImdBase para");
		b=y;
	}
	public void showImdBase()
	{
		showBase();
		System.out.println("\n b="+b);
	}
}
class Derived extends ImdBase 
{
	private int c;
	public Derived()
	{
		System.out.println("\n In Derived default");
		c=30;
	}
	public Derived(int x, int y, int z)
	{
		super(x,y);
		System.out.println("\n In Derived para");
		c=z;
	}
	public void showDerived()
	{
		showImdBase();
		System.out.println("\n c="+c);
	}
}

class MainPassParamInh
{
	public static void main(String []args)
	{
		Derived ob1=new Derived();
		ob1.showDerived();

		Derived ob2=new Derived(100,200,300);
		ob2.showDerived();
	}
}

//---------------------------------------------------------------------------------------------------

	// initializer blocks

	In Java, initializer blocks are used to initialize instance variables or perform some setup operations when an 
	object of the class is created. These blocks are executed as part of the object creation process, and they can 
	be either instance initializer blocks or static initializer blocks, depending on their purpose.

	- Types:
		1. Instance Initializer Blocks
		2. Static Initializer Blocks


	// using Instance Initializer Blocks

		- Definition: Instance initializer blocks are enclosed in curly braces {} but are not part 
		  of any method.

		- Purpose: They are used to perform instance-level initialization that is common across all 
		 	   constructors of the class.

		- Execution: Runs before the constructor and after the memory for the object is allocated.

		- Order: Executed in the order they appear in the class definition, and they run after the 
			 superclass constructor and before the subclass constructor.


	// Example 

class Example {
    int x;

    {
        // Instance initializer block
        x = 10;
        System.out.println("Instance initializer block executed");
    }

    Example() {
        System.out.println("Constructor executed");
    }

    public static void main(String[] args) {
        Example obj = new Example();
        // Output:
        // Instance initializer block executed
        // Constructor executed
    }
}

//-----------------------------

	// instace of multile init. blocks sequence in maintained while execution

class Example {
    int x;

    {
        // Instance initializer block
        x = 20;
        System.out.println("Instance initializer block executed-2");
    }

    {
        // Instance initializer block
        x = 10;
        System.out.println("Instance initializer block executed-1");
    }
    Example() {
        System.out.println("Constructor executed");
    }

    public static void main(String[] args) {
        Example obj = new Example();
        // Output:
        // Instance initializer block executed
        // Constructor executed
    }
}


//--------------------------

	/// Using the constructors and initiliser blocks in inheritance

	When we use the constructor and init block within the class in any inheritance, the execution of 
	initblock-constructor starts from base and move towards child.

class Base
{
	private int a;
	{
		System.out.println("\n In Instance init. block - Base");
	}
	public Base()
	{
		System.out.println("\n In Base default");
		a=10;
	}
	public Base(int x)
	{
		System.out.println("\n In Base para");
		a=x;
	}
	public void showBase()
	{
		System.out.println("\n a="+a);
	}
}
class ImdBase extends Base
{
	private int b;
	{
		System.out.println("\n In Instance init. block - ImdBase");
	}
	public ImdBase()
	{
		System.out.println("\n In ImdBase default");
		b=20;
	}
	public ImdBase(int x, int y)
	{
		super(x);
		System.out.println("\n In ImdBase para");
		b=y;
	}
	public void showImdBase()
	{
		showBase();
		System.out.println("\n b="+b);
	}
}
class Derived extends ImdBase 
{
	private int c;
	{
		System.out.println("\n In Instance init. block - Derived");
	}
	public Derived()
	{
		System.out.println("\n In Derived default");
		c=30;
	}
	public Derived(int x, int y, int z)
	{
		super(x,y);
		System.out.println("\n In Derived para");
		c=z;
	}
	public void showDerived()
	{
		showImdBase();
		System.out.println("\n c="+c);
	}
}

class MainPassParamInh
{
	public static void main(String []args)
	{
		Derived ob1=new Derived();
		ob1.showDerived();

		Derived ob2=new Derived(100,200,300);
		ob2.showDerived();
	}
}


//------------------------------

// what is difference between constructor and initilizer block?

	In Java, constructors and initializer blocks are mechanisms used to initialize objects, but they have different 
	purposes, syntax, and use cases. Here’s a detailed comparison:

	Constructor
	- A special method with the same name as the class.
	- Invoked explicitly when an object is created using new.
	- Can be overloaded to provide multiple ways of object initialization.
	- Executes after all initializer blocks (if present).
	- Used for object-specific initialization.
	- Cannot be static.

	Initializer Block
	- A block of code within braces {} that runs automatically when an object is created.
	- Executes before the constructor.
	- Cannot be overloaded.
	- Used for common initialization logic shared across all constructors.
	- Can also have static variants for initializing static variables, executed once when the class is loaded.



//---------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------

	// Hierarchical Inheritnce

			[ ] Person
	 		 |
	 ________________|_______________________________
	 |			|			|
	[ ] student           [   ] Employee           [   ] Driver
	 |			|                        |
	 |			|                  ---------------   
	[ ] sport          -------------------     |             |
	 |                 |         |        |   [ ] Utility   [ ] Heavy 
	 |               [  ]       [  ]     [ ]
	[ ] Result      Worker    Director    CEO

class Person {}

  class Student extends Person {}
     class Sport extends Student{}
        class Result extends Sport{}

  class Employee extends Person {}
     class Worker extends Employee{}
     class Director extends Employee{}
     class CEO extends Employee{}

  class Driver extends Person {}
     class Utility extends Driver{}
     class Heavy extends Driver{}

class MainHierarchicalExample
{
	public static void main(String []args)
	{
		Ceo ob1=new Ceo();
		boolean b= ob1 instanceof Ceo;
		System.out.println(b);

		b=ob1 instanceof Employee;
		System.out.println(b);

		b=ob1 instanceof Person;
		System.out.println(b);

		System.out.println("\n ---------------------- ");

		Result ob2=new Result();
		b=ob2 instanceof Result;
		System.out.println(b);

		b=ob2 instanceof Person;
		System.out.println(b);
	}
}

//-----------------------------------------------------------------------

	// Multiple and Hybrid inheritances - Absent in Java

	// Why multiple and Hybrid inheritances not present in Java?

	We have two more inheritances multiple and Hybrid, these inheritances are present in C++
	but as both create the Ambiguous condition, so both are eliminated from Java.

	NOTE TAHT TO GAIN GOOD PART OF THESE INHERITANCES JAVA INTRODUCED THE INTERFACE.

	Lets see, how the ambiguous condition is cerated by the both
	
	// Multiple Inheritance:


		     student		     sport
	     get()    [  ]	   	     [  ]  in()
	     put()     |	               |   put()
                       |_______________________|
                               |
                               |
                              [ ]
                             Result

                        get()       in()
                        put()       put()	
			     input()
			     output()

	when we create the object of Result class and call put() method.
	
	Result rob;
	...
	rob.put(); // creates ambiguous condition coz there are two copies of put(). 
		   // one from student and another from sport


	lets consider another class relationship

	// Hybrid Inheritance:

                    in()  Student
		    out()  [ ]               ---|
                            |                   |
                   _________|______________     | -----------> // Hierarchical Inheritnce
          in()    |	                  |out()|
	  out()   |           setdata()   |in() |
	 Set()   Exam        showdata() sport   |
	 Show()  [  ]	     	         [  ] ---
	           |	                   |    |
                   |_______________________|    | ----------> // Multiple Inheritance
                            |                   |
 			  [   ]             ----
	    in()   out()  Result  in()       out()
	   Set()   Show()         setdata()  showdata()


	Ambiguous condition is created when we make a call to in() and out() using object of Result class.


	So to eliminate these Ambiguous condition, Java dont have multiple and Hybrid inheritances.
	Note another fact that java does not needs a virtual keyword to create virtual base class.

///===================================================================================================================


	// Polymorphism in Java: It refers one name many forms. there are two
				 different types as discussed below.
	
		the word polymorphism forms as shown

		- Poly: 	many or more
		- morphism: 	forms or copies



                Polymorphism
                      |
            -----------------------
            |                     |
         Runtime /               Compile-time/
     dynamic binding /          static binding/
     dynamic polymorphism /     static polymorphism /
     late binding              early binding
            |                       |
         Overriding             Overloading
                                   - Method Overloading

	* Operator Overloading not present in Java

	We have seen, the method overloading and Constructor overloading these
	are the examples of static/compile time polymorphism.

 Lets implements Runtime Polymorphism Step by Step

	1. Suppose we want to calculate the area() of different shapes
	   i.e.
		 Rect			Triangle 		Circle
		 [   ] 			[   ]			[   ]
	   
		we can define the methods as 

		findArea()	       showArea()		calcArea()

	   Now create an object of class that you want and call respective method.

		Rect ob1;		Triangle ob2;		Circle ob3;
		ob1.findArea();		ob2.showArea();		ob3.calcArea();

	2. Now, quite modification in the program, and that is, still we want to calculate 
	   the area() of any one shape, but which? --> It will be decided at Runtime.

		- We need one pointer, coz there is dynamic memory allocation. Here in java pointer 
		  is absent, so it is solved by reference variable.

		- Important question is that, reference of which type?  Rect, Triangle or Circle.

		- reference of any one, able to refer only location of same type. we need a reference
		  variable which is able to refer any one of the above.

		- We know that, a reference variable of base class able to refer the object of its any child.

		- Lets create a common base class for all the three classes.

     					     Shape
					     [   ]
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		  findArea()	           showArea()		   calcArea()

		Now, lets implement the above hierarchy,

class Shape
{
}
class Rect extends Shape
{
	public void findArea()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void showArea()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void calcArea()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly1
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref = new ..... ; // which object? it is decided at runtime.
		ref.xxxxarea(); 

		// we are unable to call the method coz every class having a method with different name
		// to calculate the area. solution to this problem is there must be a method in all classes
		// having a same name to calculate the area.
	}
}

//-----------------------------------------------
3. lets rewrite


					     Shape
					     [   ] 
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		      area()	              area()		       area()


	- As we have defined multiple methods in different classes, it comes under the polymorphism.
	  i.e. one name many forms

	- here which method will recive a call is dependent on the option selected by the user at runtime.

	- means from multiple copies, one method for execution will be selected at runtime, therefore it is
	  called as runtime polymorphism / dynamic polymorphism.

		Now, lets implement the above hierarchy,

class Shape
{
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly2
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 
	}
}
//--------- on Compile --------

DemoRuntimePoly2.java:36: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
DemoRuntimePoly2.java:41: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
DemoRuntimePoly2.java:46: error: cannot find symbol
                ref.area();
                   ^
  symbol:   method area()
  location: variable ref of type Shape
3 errors
Press any key to continue . . .

	
//-------------------------------------------------------

	4. Will face some errors, they are due to

		- Shape ref; means reference is of Shape type, so interpreter searching the method in Shape class.

		- lets provide the method area() in Shape.

					     Shape
					     [   ]  public void area(){}
					       |
					       |
			-------------------------------------------------
			|			|			|	
		      Rect		     Triangle 		     Circle
		      [   ] 		       [   ]		      [   ]

		      area()	              area()		       area()


class Shape
{
	public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePoly3
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 
	}
}

------------- Output on Run ---------------------

In Rect area()
In Circle area()
In Triangle area()
Press any key to continue . . .


//-----------------------------------------------------------------------------------------------------------------------

	5. Note Carefully,

	- If we try same implementation in C++, then in above example we will get the output after execution of area()
	 from Shape class. and to execute the child class methods we need to decl. area() from Shape class as a Virtual.

	- this change in the behaviour, known as "Dynamic Method Dispatch"

	Dynamic Dispatch: When a method is called on an object, Java determines at runtime which version of the method 
	to execute. This is called dynamic dispatch. If the object is of the subclass type, the overridden method in 
	the subclass will be invoked.

	- As the method selection is done correctly without using virtual keyword, java eliminates the virtual keyword.

//---------------------------------------------------------------------------------------------------------------------

	6. Now we want to keep the above aritecture as it is and functional, To keep it functional every child of 
	   Shape class must override the area() method.

	   Then how to make it compulsory? 
	   (In C++, it is done with defining pure virtual function using vitrual keyword, but virtual keyword absent in java)

	   Here, the abstract keyword is provided.



					     Shape
					     [   ]  public absrtact void area();
					       |
					       |
			-------------------------------------------------========================
			|			|			|			|
		      Rect		     Triangle 		     Circle		    Parabola
		      [   ] 		       [   ]		      [   ]		      [   ]	

		      area()	              area()		       area()		     area()		



class Shape
{
	public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

---------- Output on Run --------------
In Rect area()
In Circle area()
In Triangle area()
In Shape area()
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------

	Means it is not compulsory to define the area() method within class Parabola. Now lets define the 
	base class(Shape) method as abstract.

class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Circle area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

---------------- Output on compile --------------------------

DemoRuntimePoly4.java:1: error: Shape is not abstract and does not override abstract method area() in Shape
class Shape
^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------


	7. Note that when a class contains one or more abstract methods, the class must be declare ed as abstract.
	   and we are unable to create the object of abstract class. but it is possible to create its reference.
	   Abstract class can act as the base in class hierarchy.


abstract class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Circle area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//------------------------ output on compile -----------------------------

DemoRuntimePoly4.java:26: error: Parabola is not abstract and does not override abstract method area() in Shape
class Parabola extends Shape
^
1 error
Press any key to continue . . .

	Now this error due to, as class Parabola does not have defination of area(), it contains inherited abstract
	copy of area() method.

 if we declare  class Parabola as abstract, the we will get an error as

DemoRuntimePoly4.java:57: error: Parabola is abstract; cannot be instantiated
                ref=new Parabola ();
                    ^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------------------------

	8. Note that abstract method dont have body


abstract class Shape
{
	abstract public void area()
	{
		System.out.println("In Shape area()");
	}
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void findarea()
	{
		System.out.println("In Parabola findarea()");
	}
	public void area()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly4
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//----------------- On Compile ---------------------

DemoRuntimePoly4.java:4: error: abstract methods cannot have a body
        abstract public void area()
                             ^
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

9. MEANS FINALY WE NEED TO DEFINE(OVERRIDE) THE area() METHOD IN CLASS Parabola.
	   i.e. NOW IT BECOME COMPULSORY, IF YOU WANT TO CREATE AN OBJECT OF CLASS Parabola.


abstract class Shape
{
	public abstract void area();
}
class Rect extends Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle extends Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle extends Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}
class Parabola extends Shape
{
	public void area()
	{
		System.out.println("In Parabola area()");
	}
}
class DemoRuntimePoly5
{
	public static void main(String []args)
	{
		// rather than creating the complex architecture to decide the which shape,
		// lets go for the possiblities.

		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

		// OR

		ref=new Parabola (); 
		ref.area(); 
	}
}

//--------------- output on compile -------------------
In Rect area()
In Circle area()
In Triangle area()
In Parabola area()
Press any key to continue . . .

//--------------------------------------------------------------------------------------------------------------

	// Some facts about the abstract keyword

	/// Using abstract keyword

	 The Keyword abstract used to declare  Abstract Class and Abstract Methods

	=> Abstract Class: 

	In Java, an abstract class is a class that cannot be instantiated on its own and is meant to be subclassed 
	by other classes. It serves as a blueprint for other classes, providing common functionality and structure. 	Abstract classes can have both abstract and concrete methods.

	Here are key characteristics of abstract classes in Java:

 	- It is decared as an abstract using abstract keyword.

		abstract class Demo
		{
			.......
		}

  	- Abstract class have atleast one abstract method, and child class must override the all abstract methods of 
	  base otherwise we need to declare the child class as abstract, and remember that we are not allowed to 
	  create the object of an abstract class. 

		abstract class Demo
		{
			abstract void show();
			.......
		}

  	- Abstract classes can also have regular (concrete) methods with a complete implementation

		abstract class Demo
		{
			abstract void show();
			public void display()
			{
			}
			.......
		}

  	- Abstract classes can have constructors, and they are called when a subclass object is created.

  	- Abstract classes can be used as a base class for other classes. Subclasses extend the abstract class 
	  and provide concrete implementations for the abstract methods.

  	- Abstract classes can have instance variables just like regular classes.


	abstract class Demo
	{
		private int x=10;
		public Demo()
		{
			System.out.println("\n In the Demo Class Constructor");
		}
		public void out()	
		{
			System.out.println("\n In out() method - x is "+x);
		}
		abstract void show();
	}
	class Test extends Demo
	{
		int y;
		public Test()
		{
			y=100;
			System.out.println("\n In child Test class Constructor");
		}
		public void show()
		{
			System.out.println("\n Hi from show() Test and y="+y);
		}
	}
	class DemoAbstractExample 
	{
		public static void main(String[] args) 
		{
			Test ob=new Test();
			ob.show();
			ob.out();
		}
	}

 	- The inner class can be declared abstract by declaring it local.
  	- A static method can be part of an abstract class.
  	- constructor can be part of an abstract class.
  	- When the final keyword is used, the abstract keyword cannot be used.
  	- Abstract methods cannot be declared private.
  	- Abstract methods cannot be declared static.
  	- An abstract keyword cannot be used with variables or constructors.

//========================================= Additional =============================================================

can abstract class contains inner class?

Yes, an abstract class in Java can contain an inner class. There are no restrictions that prevent an abstract class from having inner classes, whether they are regular (non-static) inner classes, static nested classes, or local/anonymous classes.

The inner class can serve as a helper or utility class for the outer abstract class.

Types of Inner Classes in Abstract Classes

1. Non-Static Inner Class
A non-static inner class is associated with an instance of the outer abstract class. It can access the instance variables and methods of the outer class, even if the class is abstract.


abstract class OuterAbstractClass {
    abstract void outerMethod();

    // Non-static inner class
    class InnerClass {
        void innerMethod() {
            System.out.println("Inner class method called");
        }
    }
}

class ConcreteClass extends OuterAbstractClass {
    void outerMethod() {
        System.out.println("Outer method implemented");
    }

    public static void main(String[] args) {
        ConcreteClass outer = new ConcreteClass();
        InnerClass inner = outer.new InnerClass();
        outer.outerMethod();
        inner.innerMethod();
    }
}

2. Static Nested Class
A static nested class is a static member of the abstract class. It does not depend on an instance of the outer class and can only access the static members of the outer class.

abstract class OuterAbstractClass {
    static void staticOuterMethod() {
        System.out.println("Static method of outer abstract class");
    }

    // Static nested class
    static class StaticNestedClass {
        void nestedMethod() {
            System.out.println("Static nested class method called");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        OuterAbstractClass.StaticNestedClass nested = new OuterAbstractClass.StaticNestedClass();
        nested.nestedMethod();
        OuterAbstractClass.staticOuterMethod();
    }
}

3. Local Inner Class
A local inner class is defined within a method of the abstract class. It can access the local variables of the method (if they are effectively final) and the members of the abstract class.

abstract class OuterAbstractClass {
    abstract void outerMethod();

    void methodWithLocalClass() {
        // Local inner class
        class LocalInnerClass {
            void localInnerMethod() {
                System.out.println("Local inner class method called");
            }
        }

        LocalInnerClass localInner = new LocalInnerClass();
        localInner.localInnerMethod();
    }
}

class ConcreteClass extends OuterAbstractClass {
    void outerMethod() {
        System.out.println("Outer method implemented");
    }

    public static void main(String[] args) {
        ConcreteClass obj = new ConcreteClass();
        obj.methodWithLocalClass();
    }
}

4. Anonymous Inner Class
An abstract class can also have an anonymous inner class. This is often used to provide an implementation for the abstract methods of the abstract class or its parent.


abstract class OuterAbstractClass {
    abstract void abstractMethod();

    void createAnonymousClass() {
        OuterAbstractClass anonymous = new OuterAbstractClass() {
            @Override
            void abstractMethod() {
                System.out.println("Abstract method implemented in anonymous inner class");
            }
        };

        anonymous.abstractMethod();
    }
}

public class Main {
    public static void main(String[] args) {
        OuterAbstractClass obj = new OuterAbstractClass() {
            @Override
            void abstractMethod() {
                System.out.println("Anonymous class implementation of abstract method");
            }
        };
        obj.abstractMethod();
    }
}
//===================================================================================================
//----------------------------------------------------------------------------------------------------

	 => Abstract method:

	In Java, an abstract method is a method that is declared without an implementation in an abstract class. An 
	abstract class is a class that cannot be instantiated on its own and may contain abstract methods, which are 
	meant to be implemented by concrete (non-abstract) subclasses. Abstract methods serve as a blueprint for 
	concrete classes to provide their own implementation.

	Here are the key points about abstract methods in Java:

  	- The abstract method declared as abstract using abstract keyword and it dont have body.

		i.e. abstract void dispay();

  	- When any method declared as abstract, the containing class must be declared as abstract.
	i.e.
		abstract class Test
		{
			abstract void display();
			....
		}
 
	- Subclasses that extend an abstract class must provide implementations for all the abstract methods declared 
	  in the superclass, otherwise you have to declare that class as abstract.

		abstract class Test
		{
			abstract void display();
			....
		}

		class Demo extends Test
		{
			.....
			public void dispay()
			{
				.....
			}
			....
		}

  	- Abstract methods provide a way to define a common interface for a group of related classes, ensuring that 
	  each concrete subclass provides its own implementation. This promotes code reusability and helps in 
	  creating a consistent interface for different classes.

 	key points about abstract classes and abstract methods in Java:
	
	Abstract Class:
	
	- An abstract class is a class that cannot be instantiated directly. It serves as a blueprint 
   	  for other classes to inherit from.
 	- Abstract classes may contain both abstract and concrete methods.
 	- Abstract classes are declared using the abstract keyword.
 	- Abstract classes can have constructors, fields, and regular methods, just like normal classes.
 	- Abstract classes can have access modifiers like public, protected, and private.
	  if class is
		public: To make the abstract class accessible to all classes.
		protected: To restrict access to the same package or subclasses.
		private: For use in nested abstract classes, fully encapsulating it within the enclosing class.
		Default (no modifier): To limit access to the package.

	Abstract Method:

 	- An abstract method is a method declared without an implementation (i.e., without a method body).
 	- Abstract methods are declared using the abstract keyword and must be contained within an abstract class.
 	- Abstract methods are meant to be implemented by subclasses. Subclasses must provide a concrete 
   	  implementation for all abstract methods unless they are also abstract classes.
 	- Subclasses that extend an abstract class with abstract methods must either provide concrete implementations 
   	  for all abstract methods or be declared as abstract themselves.

//---------------------------------------------------------------------------------------------------

	// Actual implementation of above example

abstract class Shape 
{
    // Abstract method declaration
    public abstract double area();

    // Concrete method
    public void display() 
	{
        System.out.println("This is a shape.");
    }
}

class Circle extends Shape
{
    private double radius;

    public Circle(double radius) 
    {
        this.radius = radius;
    }

    // Implementing the abstract method
    @Override
    public double area() 
    {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape 
{
    private double length;
    private double width;

    public Rectangle(double length, double width) 
    {
        this.length = length;
        this.width = width;
    }

    // Implementing the abstract method
    @Override
    public double area() 
    {
        return length * width;
    }
}

public class Main 
{
    public static void main(String[] args) 
    {
        Circle circle = new Circle(5);
        System.out.println("Area of circle: " + circle.area());

        Rectangle rectangle = new Rectangle(4, 6);
        System.out.println("Area of rectangle: " + rectangle.area());
    }
}

//--------------------------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------------------------

	// Interface in Java

	An interface in Java is a reference type that defines a contract or a set of abstract methods that a 
	class must implement. 

	It acts as a blueprint for classes. Unlike a class, an interface can contain only:

	- Abstract methods (methods without a body; method declarations)(implicitly public and abstract).
	- Constant fields (implicitly public static final).
	- Static methods (with a body, introduced in Java 8).
	- Default methods (with a body, introduced in Java 8).
	- private and private static methods (with a body, introduced in Java 9).
	- Cannot have constructors, meaning interfaces cannot be instantiated.
	- A class can implement multiple interfaces, enabling multiple inheritance in Java.

	


	Decl. Syntax;

	interface <interface_name>	e.g.
	{					interface Demo
		<fields>;			{
		<methods>;				int DATA=100;
	};						void method1();
							static void method2(){
								System.out.println("In Static method of interface");
							}
							default void method3() {
							      System.out.println("In default implementation of method in interface");
							}
						}


	- Typically, interfaces are declared with public access modifiers to allow usage across different packages.
	- Follow naming conventions: Capitalize the first letter and use camel case (e.g., Animal, Drawable).
	- Fields in an interface are always public static final, even if you don't explicitly write it.
	- Abstract Methods: Declared without a body, they must be implemented by any class that implements the interface.
	- Default Methods: Have a method body and can provide a default implementation.
	- Static Methods: Belong to the interface and can be called without an instance.


	// A Class Implements an Interface

	A class that implements an interface must provide concrete implementations for all of its abstract methods 
	unless the class itself is abstract.

interface Demo
{
	void show();
}
class Sample implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
	}
}


//--------------------------------------------------------------------------

	// A class Extends class and implements an interface

	- To extend the class, extends keyword must be used.
	- To implement, implements keyword must be used

interface Demo
{
	void show();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
	}
}

//--------------------------------------------------------------------------

	// A class extends class and implements an interface multiple interfaces

interface Demo
{
	void show();
}
interface Example
{
	void present();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo, Example
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
	public void present() {
		System.out.println("In present - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
		ob.present();
	}
}

//-------------------------------------------------------------------------------

	// Note that As one class extends the another class, One interface also extends another interface.
	// and A class implements one or more interfaces.

interface Example
{
	void present();
}
interface Demo extends Example
{
	void show();
}
class Test
{
	public void view() {
		System.out.println("In view - Test");
	}
}
class Sample extends Test implements Demo
{
	public void show() { // must be public
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
	public void present() {
		System.out.println("In present - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		System.out.println("Main Starts");
		Sample ob = new Sample();
		ob.show();
		ob.display();
		ob.view();
		ob.present();
	}
}

//-------------------------------------------------------------------------------------------

	// Knowing the facts when reference of base interface refers to object of child class.

	when a reference of a base interface refers to an object of a child class, it demonstrates the concept of 
	polymorphism. This is a fundamental object-oriented programming principle that allows a single interface 
	reference to be associated with different implementations dynamically (at runtime).

	In Such case we able to call only implemented methods from child.(methods present in same interface)

interface Demo 
{
	void show();
}

class Sample implements Demo
{
	public void show() {
		System.out.println("In Show implementation - Sample");
	}
	public void display() {
		System.out.println("In display - sample");
	}
}
class ClassImplInterface 
{
	public static void main(String[] args) 
	{
		Sample ob = new Sample();
		ob.show();
		ob.display();

		// -- Create the reference of interface(base) to refer object of class(child)

		Demo ref = new Sample();
		ref.show();
		ref.display();
		
	}
}

//----------- On Compile ------------
ClassImplInterface.java:28: error: cannot find symbol
                ref.display();
                   ^
  symbol:   method display()
  location: variable ref of type Demo
1 error
Press any key to continue . . .

//---------------------------------------------------------------------------------------------------------------------

	/// Knowing the details about the members of interface

	// Interface fields

	fields in an interface behave differently from fields in a class. Interface fields are used to define 
	constants that are shared across all implementing classes. They are fundamentally different because they 
	are implicitly public, static, and final, regardless of how they are declared.

	 - public: Accessible everywhere.
	 - static: Belong to the interface, not to any instance of the implementing class.
	 - final: Cannot be modified once initialized (constant)

interface Constants {
    int MAX_VALUE=100;  // Implicitly public, static, and final
	// init. is compulsory even if you want to keep it zero.
}

class Example implements Constants {
    void printConstant() {
        System.out.println(MAX_VALUE); // Accessing the constant
    }
}

class InterfaceFieldsExample
{
	public static void main(String []args) {
		Example ob = new Example();
		ob.printConstant();
		System.out.println(Constants.MAX_VALUE);
		System.out.println(ob.MAX_VALUE);		
	}
}

	Note: 
	 - must init the interface fields, coz they are implicitly final, (even if they are static)
	 - As it is public and static by default, it can accessed using <interface_name>.<field_name>
	 - You can access it with in implementing class directly coz it is public in interface so it is inherited.
	 - using object of implementing class you can access it directly as <obj_nm>.<field_name>, coz it os public.


	// Advantages of Interface Fields

	 - Interface fields provide a mechanism to define constants that are globally accessible throughout 
	   the application.
	 - All implementing classes share the same constant values, reducing redundancy.
	 - Fields can be accessed directly via the interface name, making them convenient to use in different 
	   parts of the application.

	//  Limitations of Interface Fields
	 
	- Fields are final, meaning their values cannot be changed once initialized. This limits their use to 
	  constant values only.
	- Since fields are static, they are not associated with any instance of a class. They cannot hold 
	  instance-specific data.
	- Using an interface solely to define constants is often considered poor design because interfaces are 
	  intended to define behavior, not data. A better alternative is to use an enum or a utility class.


	// Alternatives to Interface Fields

	 - In Java, Enum can serve as an alternative to using fields in interfaces for defining a fixed set of 
	   constants. While interface fields are traditionally used for this purpose, using Enum is often a better 
	   and more robust approach. Enums are preferred when you need to define a set of constants with type safety.

	 - Constants can also be defined in a utility class with a private constructor to prevent instantiation.

	 - For more advanced and immutable constant configurations, you can use Java record(Java 14+).

	   record is a special type of class designed to represent immutable data. It is a concise way to define 
	   a class whose main purpose is to carry data, similar to Data Transfer Objects (DTOs) or value objects.

//-------------------------------------------

	// Methods within interface

	// Public and Abstract Methods (Pre-Java 8 and Onward)
	
	Abstract methods are the core of interfaces. They define behavior that any implementing class must provide.

	Characteristics:

	- Declared without a body.
	- Must be implemented by any concrete (non-abstract) class that implements the interface.
	- Implicitly public and abstract (you can omit these modifiers).

	Purpose: Abstract methods enforce a contract, ensuring that all implementing classes share a common behavior.

	interface Animal {
    		void eat();    // Abstract method
    		void sleep();  // Abstract method
	}

	class Dog implements Animal {

    		public void eat() {
        		System.out.println("Dog is eating");
    		}

    		public void sleep() {
        		System.out.println("Dog is sleeping");
    		}
	}
	class DemoFAIM
	{
		public static void main(String []args) {

			Dog ob = new Dog();
			ob.eat();
			ob.sleep();
		}
	}


///-------------------------------------

	// Implementing runtime polymorphism using interface

interface Shape
{
	 void area();
}
class Rect implements Shape
{
	public void area()
	{
		System.out.println("In Rect area()");
	}
}
class Triangle implements Shape
{
	public void area()
	{
		System.out.println("In Triangle area()");
	}
}
class Circle implements Shape
{
	public void area()
	{
		System.out.println("In Circle area()");
	}
}

class DemoRuntimePolyusingInterface
{
	public static void main(String []args)
	{
		Shape ref;

		ref=new Rect(); 
		ref.area(); 

		// OR

		ref=new Circle(); 
		ref.area(); 

		// OR

		ref=new Triangle(); 
		ref.area(); 

	}
}

/---------------------------------------------------------------------------------------------------------------------

	// Default Methods in Interface

	Default methods in Java interfaces were introduced in Java 8 to provide method implementations in interfaces. 
	Before Java 8, interfaces could only contain abstract methods, but default methods offer a way to add 
	functionality to interfaces without breaking the existing classes that implement them.

	- Default methods allow you to define a method body (implementation) in the interface itself.
	- Default methods enable adding new methods to existing interfaces without forcing the classes that 
	  implement them to modify their code.
	- Implementing classes can override default methods if a specific implementation is needed.
	- Default methods must always be public (implicit in interfaces). They cannot be private, protected, or static.
	- If a class implements multiple interfaces with the same default method name, the class must explicitly 
	  resolve the conflict.


interface MyInterface
{
	void show();
	default void displayMessage() {
		System.out.println("This is Default Message");
	}
}
class MyClass implements MyInterface
{
	public void show() {
		System.out.println("In MyClass show()");
	}
	public void display() {
		System.out.println("In MyClass display()");
	}
}
class YourClass implements MyInterface
{
	public void show() {
		System.out.println("In YourClass show()");
	}
	public void displayMessage() {
		System.out.println("This is Custom Message");
	}
}
class DemoDefaultInterfaceMethod 
{
	public static void main(String[] args) 
	{
		MyClass ob = new MyClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	
		System.out.println("\n ------------------------------------------");

		YourClass ob1 = new YourClass();
		ob1.show();
		ob1.displayMessage();
	}
}


//---------------------------------------------------
	
	// Multiple interface implementation having default method with same name

	If a class implements multiple interfaces with the same default method, the class must explicitly 
	resolve the conflict.

interface MyInterface
{
	void show();
	default void displayMessage() {
		System.out.println("This is Default Message - MyInterface");
	}
}
interface YourInterface
{
	void display();
	default void displayMessage() {
		System.out.println("This is Default Message - YourInterface");
	}
}
class CommanClass implements MyInterface, YourInterface
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
	public void displayMessage() {
		YourInterface.super.displayMessage();
		MyInterface.super.displayMessage();
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommanClass ob = new CommanClass();
		ob.show();
		ob.display();
		ob.displayMessage();
		ob.displayMessage();

	}
}

	// Error in case of conflict
	//  error: types MyInterface and YourInterface are incompatible;
	// class CommanClass inherits unrelated defaults for displayMessage() from types MyInterface and YourInterface

	Note: you cannot directly call A.super.greet() or B.super.greet() from the main method. 
	The super keyword is used to access a parent interface's or class's method from within the child 
	class that implements or extends it.

//------------------------------------------------------------------------

	// A class extends class and implements interface where class having show() method and interface
	// having default implementation of show() - Both acts as base of CommonClass class.

	--> In such case, no ambiguous condition, compiler gives priority to copy of show() via class.

class MyClass
{
	void show(){}
	public void displayMessage() {
		System.out.println("This is Default Message - Myclass");
	}
}
interface YourInterface
{
	void display();
	default void displayMessage() {
		System.out.println("This is Default Message - YourInterface");
	}
}
class CommonClass extends MyClass implements YourInterface 
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommonClass ob = new CommonClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	}
}


//-------------------------------------------------------------------------------

	// In case of class extends class and implements interface where a base having implementation of method,
	// and same method present in base interface(public and abstract), in such case, method implementation in
	// child is optional, and in such case, it will takes inherited copy of method from class as an implementation.


class MyClass
{
	void show(){}
	public void displayMessage() {
		System.out.println("This is Default Message - Myclass");
	}
}
interface YourInterface
{
	void display();
	void displayMessage();
}
class CommonClass extends MyClass implements YourInterface 
{
	public void show() {
		System.out.println("In CommanClass show()");
	}
	public void display() {
		System.out.println("In CommanClass display()");
	}
}

class DefaultMethodConfilct
{
	public static void main(String[] args) 
	{
		CommonClass ob = new CommonClass();
		ob.show();
		ob.display();
		ob.displayMessage();
	}
}

//---------------------------------------------------------------------------------------------------------

	// Static methods in interfaces

	Static methods in interfaces were introduced in Java 8. Unlike instance methods or default methods, 
	static methods belong to the interface itself and are not inherited by implementing classes. They serve 
	utility-like functionality, similar to static methods in classes, but are specific to the interface.


	Characteristics of Static Methods in Interfaces

	- Static methods are part of the interface itself, not the implementing class.
	- They are called using the interface name, not the implementing class name or an object.
	- Implementing classes do not inherit static methods from the interface.
	- They cannot be overridden by the implementing classes.
	- Provide utility or helper methods related to the interface.
	- Avoid creating a separate utility class to hold such methods.
	- Static methods in interfaces are always public by default.
	- They cannot have any other access modifier (private, protected, or package-private).

interface MathOperations {

    static int add(int a, int b) {
        return a + b;
    }

    static int multiply(int a, int b) {
        return a * b;
    }
}

public class StaticMethodsInInterface {
    public static void main(String[] args) {

        // Calling static methods using the interface name
        System.out.println("Addition: " + MathOperations.add(5, 3));    // Output: 8
        System.out.println("Multiplication: " + MathOperations.multiply(5, 3)); // Output: 15
    }
}


	Static Methods vs Default Methods:
	-----------------------------------

	- Static methods belong to the interface and cannot be called on objects.
	- Default methods are instance methods and can be called on objects of the implementing class.

//---------------------------------------------------------------------------------------------------------

	// Private Methods in Interfaces (Java 9)

	Private methods in interfaces, introduced in Java 9, are designed to provide shared, reusable logic 
	within the interface. These methods are accessible only within the interface itself and are not 
	visible to implementing classes or other interfaces.
	
	- This avoids code duplication in default and static methods.
	- Private methods can only be called by default or static methods within the same interface.
	- They are not inherited by implementing classes.
	- Private methods in interfaces must have a body (implementation). They cannot be abstract.
	- Private methods can have two forms:
		- Instance-level private methods: Can be called from default method only.
		- Static private methods: Declared with static and invoked by static methods and default methods.


interface Greeting {
    // Default method using a private instance method
    default void sayHello() {
        System.out.println("Default sayHello method:");
        log("Hello from default method");
		logStatic("Hi from default method");
    }

    // Static method using a private static method
    static void sayHi() {
        System.out.println("Static sayHi method:");
        logStatic("Hi from static method");
		// log("Hello from default method"); // error: non-static method log(String) cannot be referenced from a static context
    }

    // Private instance method
    private void log(String message) {
        System.out.println("Logging: " + message);
    }

    // Private static method
    private static void logStatic(String message) {
        System.out.println("Logging (static): " + message);
    }
}

public class PrivateStaticMethods {
    public static void main(String[] args) {
        Greeting obj = new Greeting() {}; // Anonymous implementation of Greeting

        // Call the default method
        obj.sayHello();

        // Call the static method
        Greeting.sayHi();
    }
}
/-----------------------------------------------------------------------------------------------

	// Difference Between Class and Interface
	// Difference between abstract class and Interface.

//-----------------------------------------------------------------------------------------------
//======================================================================================================

	// Write a program to peform the stack by implementing given StackFormat interface.

interface StackFormat {
	void push(int);
	int pop();
}

//--------------
import java.util.Scanner;
interface StackFormat {
	void push(int t);
	int pop();
}
class MyStack implements StackFormat
{
	int []data = null;
	int top;

	public MyStack() {

		top=-1;
		data = new int[10];
	}

	public void push( int t) {

		top++;
		if(top>=data.length) {
			top--;
			System.out.println("Stack is Full");
		}
		else {
			data[top]=t;
			System.out.println("\n Data Insertation Sucessful...!!");
		}
	}

	public int pop() {

		if(top<0) {
			System.out.println("Stack is empty");
			return -1;
		}
		else
			return data[top--];
	}
}
class StackByInterface
{
	public static void main(String []args)
	{
		StackFormat stack = new MyStack();
		Scanner sc = new Scanner(System.in);
		int no, opt;
		while(true) {		
			System.out.println("\n ========== Menu ==========");
			System.out.println("\n 1.Push \n 2.Pop \n 3.Stop");
			System.out.println("\n Select your option: ");
			opt=sc.nextInt();
			switch(opt) {
				case 1:
					System.out.println("Enter any Number: ");
					no=sc.nextInt();
					stack.push(no);
					break;
				case 2:
					no=stack.pop();
					if(no!=-1)
						System.out.println("Poped No: "+no);
					break;
				default:
					System.out.println("\n Incorrect option: ");
			}
		}
	}
}

//----------------------------------------------------------------------------------------------------

	// Types of interfaces in java: 

	 - Basic Interface:
	 - Marker Interface:
	 - Functional Interface:



	1. Basic Interface: The Interface we have seen till Now.

//-----------------------------

	2. Marker Interface / Empty Interface / Tag Interface

	   A Marker Interface is a special type of interface in Java that does not contain any methods 
	   or fields. It is also known as a Tag Interface because its primary purpose is to act as a 
	   tag or a marker to indicate a specific property or capability of a class implementing it.

	  Marker interfaces convey metadata to the JVM or frameworks about a class's ability to perform
	  specific actions (e.g., serialization, cloning, or remote access).
	  
	  Frameworks or libraries can check at runtime if a class implements a marker interface and 
	  apply specific logic accordingly.	








