Introduction to Java

 - Java is a class-based, object-oriented programming language that was developed by James Gosling at Sun Microsystems Inc. in May 1995 and later acquired by Oracle Corporation.

History of Java

 - Java was created in 1991 by James Gosling, Mike Sheridan, and Patrick Naughton at Sun Microsystems, initially called "Oak."
 - It was renamed "Java," inspired by Java coffee.
 - Java 1.0 was publicly released in 1996, offering a free runtime environment across platforms.
 - Arthur Van Hoff rewrote the Java 1.0 compiler to strictly adhere to its specifications, enhancing reliability and cross-platform functionality.
 - Java 2 introduced configurations for different platforms, demonstrating its adaptability.
 - Sun Microsystems attempted to formalize Java through ISO in 1997 but later withdrew.
 - Despite not formalizing through ISO, Sun Microsystems offered most Java implementations at no cost, earning revenue by licensing specialized products such as the Java Enterprise System.
 - On November 13, 2006, Sun Microsystems released much of the JVM as free, open-source software.
 - By May 8, 2007, the core JVM code was fully open-source.
 - Java is widely used in mobile devices, internet programming, gaming, and e-business.
 - Java remains a cornerstone of modern software development, widely used across industries and platforms.

Key Features of Java

1. Platform Independent
	Compiler converts source code to byte code and then the JVM executes the bytecode generated by the compiler. JVM is Platform Dependent which makes Java Platform Independent.

2. Object Oriented Programming
	Java is an object-oriented language, promoting the use of objects and classes. Organizing the program in the terms of a collection of objects is a way of object-oriented programming, each of which represents an instance of the class.

3. Simplicity
	Java’s syntax is simple and easy to learn, especially for those familiar with C or C++. It eliminates complex features like pointers and multiple inheritances, making it easier to write, debug, and maintain code.

4. Robustness
	Java language is robust which means reliable. It is developed in such a way that it puts a lot of effort into checking errors as early as possible, that is why the java compiler is able to detect even those errors that are not easy to detect by another programming language. The main features of java that make it robust are garbage collection, exception handling, and memory allocation.

5. Security
	In java, we don’t have pointers, so we cannot access out-of-bound arrays i.e it shows ArrayIndexOutOfBound Exception if we try to do so. That’s why several security flaws like stack corruption or buffer overflow are impossible to exploit in Java. Also, java programs run in an environment that is independent of the os(operating system) environment which makes java programs more secure.

6. Distributed
	We can create distributed applications using the java programming language. Remote Method Invocation and Enterprise Java Beans are used for creating distributed applications in java. The java programs can be easily distributed on one or more systems that are connected to each other through an internet connection.

7. Multithreading
	Java supports multithreading, enabling the concurrent execution of multiple parts of a program. This feature is particularly useful for applications that require high performance, such as games and real-time simulations.

8. Portability
	Java's platform-independent bytecode enables "Write Once, Run Anywhere" (WORA). The generated .class file can run on any platform, making Java architecture-neutral and ideal for global enterprise applications.

9. High Performance
	Java architecture is defined in such a way that it reduces overhead during the runtime and at some times java uses Just In Time (JIT) compiler where the compiler compiles code on-demand basis where it only compiles those methods that are called making applications to execute faster.

How Java Program Executes
1. Creating the Program
Java programs are written using a text editor or an Integrated Development Environment (IDE) like IntelliJ IDEA, Eclipse, or NetBeans. The source code is saved with a .java extension.

2. Compiling the Program
The Java compiler (javac) converts the source code into bytecode, which is stored in a .class file. This bytecode is platform-independent and can be executed on any machine with a JVM.

3. Running the Program
The JVM executes the compiled bytecode, translating it into machine code specific to the operating system and hardware.

Essential Java Terminologies

1. Java Virtual Machine(JVM)
	The JVM is an integral part of the Java platform, responsible for executing Java bytecode. It ensures that the output of Java programs is consistent across different platforms.

2. Bytecode
	Bytecode is the intermediate representation of Java code, generated by the Java compiler. It is platform-independent and can be executed by the JVM.

3. Java Development Kit(JDK)
	The Java Development Kit (JDK) is a comprehensive package of tools and components required for developing and running Java applications. It is a core component for Java developers.

4. Java Runtime Environment(JRE)
	JDK includes JRE. JRE installation on our computers allows the java program to run, however, we cannot compile it. JRE includes a browser, JVM, applet support, and plugins. For running the java program, a computer needs JRE.

5. Garbage Collector
	The Garbage Collector (GC) in Java is a part of the Java Virtual Machine (JVM) responsible for automatic memory management. It helps reclaim memory occupied by objects that are no longer in use, preventing memory leaks and optimizing application performance.

6. ClassPath
	The Classpath in Java is a parameter used by the Java Virtual Machine (JVM) and the Java Compiler (javac) to locate and load classes and resources during program execution or compilation.

JVM Architecture
	JVM(Java Virtual Machine) runs Java applications as a run-time engine. JVM is the one that calls the main method present in a Java code.
 - When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM. 

1. Class Loader Subsystem
It is mainly responsible for three activities. 
Loading
Linking
Initialization

 - Loading
The Class loader reads the “.class” file, generate the corresponding binary data and save it in the method area. For each “.class” file, JVM stores the following information in the method area.
 The fully qualified name of the loaded class and its immediate parent class.
 Whether the “.class” file is related to Class or Interface or Enum.
 Modifier, Variables and Method information etc.

After loading the “.class” file, JVM creates an object of type Class to represent this file in the heap memory. 

 - Linking
Performs verification, preparation, and (optionally) resolution.

 Verification: 
	It ensures the correctness of the .class file i.e. it checks whether this file is properly formatted and generated by a valid compiler or not. If verification fails, we get run-time exception java.lang.VerifyError. This activity is done by the component ByteCodeVerifier. Once this activity is completed then the class file is ready for compilation.
 
 Preparation: 
	JVM allocates memory for class static variables and initializing the memory to default values. 
 
 Resolution: 
	It is the process of replacing symbolic references from the type with direct references. It is done by searching into the method area to locate the referenced entity.

 - Initialization
In this phase, all static variables are assigned with their values defined in the code and static block(if any). This is executed from top to bottom in a class and from parent to child in the class hierarchy.

JVM follows the Delegation-Hierarchy principle to load classes. 
System class loader delegate load request to extension class loader and extension class loader delegate request to the bootstrap class loader. 
If a class found in the boot-strap path, the class is loaded otherwise request again transfers to the extension class loader and then to the system class loader. 
At last, if the system class loader fails to load class, then we get run-time exception java.lang.ClassNotFoundException. 

2. Class Loaders
There are three primary types of class loaders:

Bootstrap Class Loader: Loads core Java API classes from the JAVA_HOME/lib directory. It is implemented in native code and is not a Java object.

Extension Class Loader: Loads classes from the JAVA_HOME/jre/lib/ext directory or any directory specified by the java.ext.dirs system property. It is implemented in Java.

System/Application Class Loader: Loads classes from the application classpath, which is specified by the java.class.path environment variable. It is also implemented in Java.

3. JVM Memory Areas

Method area: In the method area, all class level information like class name, immediate parent class name, methods and variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a shared resource. 

Heap area: Information of all objects is stored in the heap area. There is also one Heap Area per JVM. It is also a shared resource.

Stack area: For every thread, JVM creates one run-time stack which is stored here. Every block of this stack is called activation record/stack frame which stores methods calls. All local variables of that method are stored in their corresponding frame. After a thread terminates, its run-time stack will be destroyed by JVM. It is not a shared resource.

PC Registers: Store address of current execution instruction of a thread. Obviously, each thread has separate PC Registers.

Native method stacks: For every thread, a separate native stack is created. It stores native method information.

4. Execution Engine 
Execution engine executes the “.class” (bytecode). It reads the byte-code line by line, uses data and information present in various memory area and executes instructions. It can be classified into three parts:

Interpreter: It interprets the bytecode line by line and then executes. The disadvantage here is that when one method is called multiple times, every time interpretation is required.

Just-In-Time Compiler(JIT) : It is used to increase the efficiency of an interpreter. It compiles the entire bytecode and changes it to native code so whenever the interpreter sees repeated method calls, JIT provides direct native code for that part so re-interpretation is not required, thus efficiency is improved.

Garbage Collector: It destroys un-referenced objects. For more on Garbage Collector, refer Garbage Collector. 

5. Java Native Interface (JNI)
It is an interface that interacts with the Native Method Libraries and provides the native libraries(C, C++) required for the execution. It enables JVM to call C/C++ libraries and to be called by C/C++ libraries which may be specific to hardware.

6. Native Method Libraries
These are collections of native libraries required for executing native methods. They include libraries written in languages like C and C++.

Java Development Kit(JDK)
The Java Development Kit (JDK) is a cross-platformed software development environment that offers a collection of tools and libraries necessary for developing Java-based software applications and applets. 
JDK=JRE+Development Tools

The Java Development Kit  is an implementation of  one of the Java Platform:
Standard Edition (Java SE),
Java Enterprise Edition (Java EE),
Micro Edition (Java ME),

Contents of JDK
The JDK has a private Java Virtual Machine (JVM) and a few other resources necessary for the development of a Java Application. 

JDK contains:

Java Runtime Environment (JRE),
An interpreter/loader (Java),
A compiler (javac),
An archiver (jar) and many more.

Java Runtime Environment(JRE)
The JRE is an installation package that provides an environment to only run(not develop) the Java program (or application) onto your machine. JRE is only used by those who only want to run Java programs that are end-users of your system.

Working of JRE
When you run a Java program, the following steps occur:

Class Loader: The JRE’s class loader loads the .class file containing the bytecode into memory.
Bytecode Verifier: The bytecode verifier checks the bytecode for security and correctness.
Interpreter: The JVM interprets the bytecode and executes the program.
Execution: The program executes, making calls to the underlying hardware and system resources as needed.

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------

Java Identifiers

An identifier in Java is the name given to Variables, Classes, Methods, Packages, Interfaces, etc. These are the unique names and every Java Variables must be identified with unique names.

Rules For Naming Java Identifiers
There are certain rules for defining a valid Java identifier. These rules must be followed, otherwise, we get a compile-time error. These rules are also valid for other languages like C, and C++. 

The only allowed characters for identifiers are all alphanumeric characters([A-Z],[a-z],[0-9]), ‘$‘(dollar sign) and ‘_‘ (underscore).
Java identifiers are case-sensitive.
There is no limit on the length of the identifier but it is advisable to use an optimum length of 4 – 15 letters only.
Reserved Words can’t be used as an identifier. For example “int while = 20;” is an invalid statement as a while is a reserved word. There are 53 reserved words in Java.

Java Keywords

In Java, Keywords are the Reserved words in a programming language that are used for some internal process or represent some predefined actions. These words are therefore not allowed to use as variable names or objects. 

Java Data Types

Java is statically typed and also a strongly typed language because, in Java, each type of data (such as integer, character, hexadecimal, packed decimal, and so forth) is predefined as part of the programming language and all constants or variables defined for a given program must be described with one of the Java data types.

Data types in Java are of different sizes and values that can be stored in the variable that is made as per convenience and circumstances to cover up all test cases. Java has two categories in which data types are segregated

Primitive Data Type: such as boolean, char, int, short, byte, long, float, and double. The Boolean with uppercase B is a wrapper class for the primitive data type boolean in Java.
Non-Primitive Data Type or Object Data type: such as String, Array, etc.

Primitive Data Types

boolean: Represents true/false values. Size: Implementation-dependent (typically 1 byte).
Syntax: boolean booleanVar;

byte: 8-bit signed integer for memory-efficient arrays.
Size: 1 byte (8 bits). Syntax: byte byteVar;

short: 16-bit signed integer for saving memory in constrained environments.
Size: 2 bytes (16 bits). Syntax: short shortVar;

int: 32-bit signed integer (can represent unsigned values in Java 8+).
Size: 4 bytes (32 bits). Syntax: int intVar;

long: 64-bit signed integer (supports unsigned values in Java 8+).
Size: 8 bytes (64 bits). Syntax: long longVar;

float: 32-bit single-precision floating-point for large arrays.
Size: 4 bytes (32 bits). Syntax: float floatVar;

double: 64-bit double-precision floating-point for general decimal calculations.
Size: 8 bytes (64 bits). Syntax: double doubleVar;

Note: Use BigDecimal for high precision.

char: 16-bit Unicode character.
Size: 2 bytes (16 bits). Syntax: char charVar;

Why is the Size of char 2 bytes in Java?
Unlike languages such as C or C++ that use the ASCII character set, Java uses the Unicode character set to support internationalization. Unicode requires more than 8 bits to represent a wide range of characters from different languages, including Latin, Greek, Cyrillic, Chinese, Arabic, and more. As a result, Java uses 2 bytes to store a char, ensuring it can represent any Unicode character.

Non-Primitive Data Types:

String:
Represents a sequence of characters.
Defined as a class in Java (java.lang.String).
Example:
String str = "Hello";

Arrays:
Collection of elements of the same data type.
Fixed size, accessed via indices.
Example:
int[] numbers = {1, 2, 3, 4};

Classes:
User-defined data types containing fields and methods.
Example:
class Person {
    String name;
    int age;
}

Interfaces:
Defines a contract of methods to be implemented by classes.
Example:
interface Vehicle {
    void start();
}

Enums:
Represents a fixed set of constants.
Example:
enum Color {
    RED, GREEN, BLUE;
}

Java Variables

Variables are the containers for storing the data values or you can also call it a memory location name for the data. Every variable has a:

Data Type – The kind of data that it can hold. For example, int, string, float, char, etc.
Variable Name – To identify the variable uniquely within the scope.
Value – The data assigned to the variable.

There are three types of variables in Java – Local, Instance, and Static.

Scope of Variables in Java

The scope of variables is the part of the program where the variable is accessible.

Java Scope Rules can be covered under the following categories. 
Instance Variables
Static Variables
Local Variables
Parameter Scope
Block Scope

Important Points about Variable Scope in Java 

In general, a set of curly brackets { } defines a scope.
In Java we can usually access a variable as long as it was defined within the same set of brackets as the code we are writing or within any curly brackets inside of the curly brackets where the variable was defined.
Any variable defined in a class outside of any method can be used by all member methods.
When a method has the same local variable as a member, “this” keyword can be used to reference the current class variable.
For a variable to be read after the termination of a loop, It must be declared before the body of the loop. 

Java Operators

Java operators are special symbols that perform operations on variables or values. They can be classified into several categories based on their functionality.

Types of Operators in Java
Arithmetic Operators
Unary Operators
Assignment Operator
Relational Operators
Logical Operators
Ternary Operator
Bitwise Operators
Shift Operators
instance of operator

1. Arithmetic Operators
Arithmetic Operators are used to perform simple arithmetic operations on primitive and non-primitive data types. 

* : Multiplication
/ : Division
% : Modulo
+ : Addition
– : Subtraction

2. Unary Operators
Unary Operators need only one operand. They are used to increment, decrement, or negate a value. 

- , Negates the value.
+ , Indicates a positive value (automatically converts byte, char, or short to int).
++ , Increments by 1.
Post-Increment: Uses value first, then increments.
Pre-Increment: Increments first, then uses value.
-- , Decrements by 1.
Post-Decrement: Uses value first, then decrements.
Pre-Decrement: Decrements first, then uses value.
! , Inverts a boolean value.

3. Assignment Operator
 ‘=’ Assignment operator is used to assign a value to any variable. It has right-to-left associativity, i.e. value given on the right-hand side of the operator is assigned to the variable on the left, and therefore right-hand side value must be declared before using it or should be a constant. 

The general format of the assignment operator is:

variable = value; 

In many cases, the assignment operator can be combined with others to create shorthand compound statements. For example, a += 5 replaces a = a + 5. Common compound operators include:

+= , Add and assign.
-= , Subtract and assign.
*= , Multiply and assign.
/= , Divide and assign.
%= , Modulo and assign.

4. Relational Operators
Relational Operators are used to check for relations like equality, greater than, and less than. They return boolean results after the comparison and are extensively used in looping statements as well as conditional if-else statements. The general format is , 

variable relation_operator value 

Relational operators compare values and return boolean results:

== , Equal to.
!= , Not equal to.
< , Less than.
<= , Less than or equal to.
> , Greater than.
>= , Greater than or equal to.

5. Logical Operators
Logical Operators are used to perform “logical AND” and “logical OR” operations, similar to AND gate and OR gate in digital electronics. They have a short-circuiting effect, meaning the second condition is not evaluated if the first is false.

Conditional operators are:

&&, Logical AND: returns true when both conditions are true.
||, Logical OR: returns true if at least one condition is true.
!, Logical NOT: returns true when a condition is false and vice-versa

6. Ternary operator
The Ternary Operator is a shorthand version of the if-else statement. It has three operands and hence the name Ternary. The general format is ,

condition ? if true : if false 

The above statement means that if the condition evaluates to true, then execute the statements after the ‘?’ else execute the statements after the ‘:’.  

7. Bitwise Operators
Bitwise Operators are used to perform the manipulation of individual bits of a number and with any of the integer types. They are used when performing update and query operations of the Binary indexed trees. 

& (Bitwise AND) – returns bit-by-bit AND of input values.
| (Bitwise OR) – returns bit-by-bit OR of input values.
^ (Bitwise XOR) – returns bit-by-bit XOR of input values.
~ (Bitwise Complement) – inverts all bits (one’s complement).

8. Shift Operators
Shift Operators are used to shift the bits of a number left or right, thereby multiplying or dividing the number by two, respectively. They can be used when we have to multiply or divide a number by two. The general format , 

 number shift_op number_of_places_to_shift; 

<< (Left shift) – Shifts bits left, filling 0s (multiplies by a power of two).
>> (Signed right shift) – Shifts bits right, filling 0s (divides by a power of two), with the leftmost bit depending on the sign.
>>> (Unsigned right shift) – Shifts bits right, filling 0s, with the leftmost bit always 0.

9. instanceof operator
The instance of operator is used for type checking. It can be used to test if an object is an instance of a class, a subclass, or an interface. The general format ,  

object instance of class/subclass/interface 


